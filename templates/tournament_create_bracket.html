{% extends "base.html" %}

{% block content %}
<div class="tournament-header">
    <div class="tournament-title">
        <h1>{{ tournament['Tournament Name'] }}</h1>
    </div>
    {% include 'tournament_submenu.html' %}
</div>

<div class="container">
    <div class="content">
        <div class="bracket-controls">
            <select id="categorySelect" class="form-control">
                <option value="">Select Category</option>
                {% for category in categories %}
                <option value="{{ category }}">{{ category }}</option>
                {% endfor %}
            </select>
            <button id="generateBracket" class="btn btn-primary" disabled>Generate Bracket</button>
        </div>

        <div class="bracket-container">
            <div id="bracket" class="bracket">
                <!-- Bracket will be generated here -->
            </div>
        </div>
    </div>
</div>

<div class="popup-overlay" id="popupOverlay"></div>
<div class="success-popup" id="successPopup">
    <h3>Match Details</h3>
    <div id="matchDetails"></div>
    
    <form id="scoreForm" class="score-form">
        <input type="hidden" id="roundIndex" name="roundIndex">
        <input type="hidden" id="matchIndex" name="matchIndex">
        
        <div class="player-columns">
            <div class="player-column" id="player1NameHeader"></div>
            <div class="player-column" id="player2NameHeader"></div>
        </div>
        
        <div class="score-row">
            <label>Game 1:</label>
            <div class="score-inputs">
                <input type="number" id="player1Game1" name="player1Game1" class="score-input" min="0" placeholder="0">
                <input type="number" id="player2Game1" name="player2Game1" class="score-input" min="0" placeholder="0">
            </div>
        </div>
        
        <div class="score-row">
            <label>Game 2:</label>
            <div class="score-inputs">
                <input type="number" id="player1Game2" name="player1Game2" class="score-input" min="0" placeholder="0">
                <input type="number" id="player2Game2" name="player2Game2" class="score-input" min="0" placeholder="0">
            </div>
        </div>
        
        <div class="score-row">
            <label>Game 3:</label>
            <div class="score-inputs">
                <input type="number" id="player1Game3" name="player1Game3" class="score-input" min="0" placeholder="0">
                <input type="number" id="player2Game3" name="player2Game3" class="score-input" min="0" placeholder="0">
            </div>
        </div>
        
        <div class="button-group">
            <button type="button" class="cancel-btn" id="closePopup">Cancel</button>
            <button type="submit" class="save-btn">Save Scores</button>
        </div>
    </form>
</div>

<!-- Add this HTML for the player swap popup -->
<div class="swap-popup" id="swapPopup">
    <h3>Swap Player</h3>
    <div id="swapDetails"></div>
    
    <div class="swap-content">
        <p>Select a player to swap with:</p>
        <div class="swap-options" id="swapOptions">
            <!-- Player options will be generated here -->
        </div>
    </div>
    
    <div class="button-group">
        <button type="button" class="cancel-btn" id="closeSwapPopup">Cancel</button>
        <button type="button" class="save-btn" id="confirmSwap">Confirm Swap</button>
    </div>
</div>

<style>
    .bracket-controls {
        margin-bottom: 20px;
        display: flex;
        gap: 10px;
        align-items: center;
    }

    .form-control {
        padding: 8px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        min-width: 200px;
    }

    .btn {
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 500;
    }

    .btn-primary {
        background: #1e3c72;
        color: white;
    }

    .btn-primary:disabled {
        background: #ccc;
        cursor: not-allowed;
    }

    .bracket-container {
        overflow-x: auto;
        padding: 20px 0;
        background: #f8f9fa;
        border-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .bracket {
        display: flex;
        flex-direction: row;
        gap: 30px;
        min-width: max-content;
        padding: 20px;
    }

    .round {
        display: flex;
        flex-direction: column;
        position: relative;
    }

    /* Fixed height for matches - reduced size */
    .match {
        background: white;
        border: 1px solid #ddd;
        border-radius: 4px;
        padding: 8px;
        min-width: 160px;
        position: relative;
        height: 60px;
        display: flex;
        flex-direction: column;
        justify-content: center;
        margin-bottom: 15px;
        transition: box-shadow 0.2s;
    }

    /* Arrow icon styling */
    .match-arrow {
        position: absolute;
        right: -12px;
        top: 50%;
        transform: translateY(-50%);
        width: 24px;
        height: 24px;
        border-radius: 50%;
        background-color: #1e3c72;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
        z-index: 10;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        transition: transform 0.2s, background-color 0.2s;
    }
    
    .match-arrow:hover {
        transform: translateY(-50%) scale(1.1);
        background-color: #2a4f9e;
    }
    
    .match-arrow::after {
        content: 'â†’';
        color: white;
        font-size: 14px;
        font-weight: bold;
    }
    
    /* Only add hover effect to the arrow, not the match box */
    .match:hover {
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    }

    /* Calculate vertical positioning for each round */
    .round:nth-child(1) .match {
        margin-bottom: 15px;
    }

    .round:nth-child(2) .match {
        margin-top: 37.5px;
    }

    .round:nth-child(3) .match {
        margin-top: 112.5px;
    }

    .round:nth-child(4) .match {
        margin-top: 262.5px;
    }

    /* Connecting lines between matches */
    .match::after,
    .match::before,
    .round:not(:first-child) .match::before,
    .round:not(:first-child) .match:nth-child(odd)::before,
    .round:not(:first-child) .match:nth-child(even)::before {
        display: none !important;
        content: none !important;
    }

    .player {
        padding: 6px;
        border-radius: 4px;
        margin-bottom: 3px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.9em;
    }

    .player:last-child {
        margin-bottom: 0;
    }

    .player.winner {
        background-color: #e3f2fd;
        border-left: 3px solid #1e3c72;
    }

    .player.bye {
        background: #f8f9fa;
        color: #666;
    }

    .seed {
        color: #666;
        font-size: 0.8em;
    }

    .round-title {
        text-align: center;
        margin-bottom: 8px;
        color: #1e3c72;
        font-weight: 500;
        font-size: 0.9em;
    }

    /* Add spacing between rounds */
    .round:not(:first-child) {
        margin-left: 30px;
    }

    /* Add connecting lines from the middle of the first and second matches of round 1 to the middle of the first match of round 2 */
    .round:nth-child(1) .match:nth-child(1)::after {
        content: '';
        position: absolute;
        left: -30px;
        top: 50%;
        width: 30px;
        height: 2px;
        background: #ff0000;
        z-index: 1;
    }

    .round:nth-child(1) .match:nth-child(2)::after {
        content: '';
        position: absolute;
        left: -30px;
        top: 50%;
        width: 30px;
        height: 2px;
        background: #ff0000;
        z-index: 1;
    }

    .round:nth-child(2) .match:nth-child(1)::before {
        content: '';
        position: absolute;
        left: -30px;
        top: 50%;
        width: 2px;
        height: 50%;
        background: #ff0000;
        z-index: 1;
    }

    /* Style for the success popup */
    .success-popup {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 25px;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        text-align: center;
        min-width: 350px;
        max-width: 90%;
    }
    
    .success-popup h3 {
        margin-top: 0;
        color: #1e3c72;
        margin-bottom: 15px;
    }
    
    .popup-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        z-index: 999;
    }
    
    /* Score entry form styling */
    .score-form {
        margin-top: 15px;
        text-align: left;
    }
    
    .match-players {
        display: flex;
        justify-content: space-between;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid #eee;
        text-align: center;
    }
    
    .player-name {
        font-weight: 500;
        color: #333;
        flex-basis: 45%;
        text-align: center;
    }
    
    .vs-label {
        margin: 0 10px;
        align-self: center;
        color: #666;
    }
    
    .score-row {
        display: flex;
        align-items: center;
        margin-bottom: 15px;
    }
    
    .score-row label {
        flex-basis: 60px;
        font-weight: 500;
    }
    
    .score-inputs {
        display: flex;
        justify-content: space-between;
        flex-grow: 1;
    }
    
    .score-input {
        width: 45%;
        text-align: center;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
    }
    
    .score-input:focus {
        border-color: #1e3c72;
        outline: none;
    }
    
    .button-group {
        margin-top: 20px;
        display: flex;
        justify-content: space-between;
    }
    
    .button-group button {
        padding: 8px 16px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 500;
    }
    
    .save-btn {
        background-color: #1e3c72;
        color: white;
    }
    
    .save-btn:hover {
        background-color: #2a4f9e;
    }
    
    .cancel-btn {
        background-color: #f1f1f1;
        color: #333;
    }
    
    .cancel-btn:hover {
        background-color: #e1e1e1;
    }
    
    /* Score display in matches */
    .player .score-display {
        margin-left: auto;
        color: #666;
        font-size: 0.9em;
    }

    /* Styling for BYE matches */
    .bye-message {
        background-color: #f8f9fa;
        padding: 15px;
        border-radius: 6px;
        margin: 15px 0;
        text-align: center;
        border-left: 4px solid #1e3c72;
    }
    
    .score-form.disabled {
        opacity: 0.7;
        pointer-events: none;
    }

    /* Make sure cancel button is always enabled */
    .score-form.disabled .cancel-btn {
        opacity: 1;
        pointer-events: auto;
    }
    
    /* Cancel button styling */
    .cancel-btn {
        background-color: #f1f1f1;
        color: #333;
    }
    
    .cancel-btn:hover {
        background-color: #e1e1e1;
    }

    /* Add column headers for players */
    .player-columns {
        display: flex;
        justify-content: space-between;
        margin-bottom: 10px;
    }
    
    .player-column {
        flex-basis: 45%;
        text-align: center;
        font-weight: 500;
        padding: 5px;
        background-color: #f5f7fa;
        border-radius: 4px;
        color: #1e3c72;
    }

    /* Make player names clickable */
    .player span:first-child {
        cursor: pointer;
        transition: color 0.2s;
    }
    
    .player span:first-child:hover {
        color: #1e3c72;
        text-decoration: underline;
    }
    
    /* Styles for the swap popup */
    .swap-popup {
        display: none;
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background-color: white;
        padding: 25px;
        border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        text-align: center;
        min-width: 350px;
        max-width: 90%;
    }
    
    .swap-popup h3 {
        margin-top: 0;
        color: #1e3c72;
        margin-bottom: 15px;
    }
    
    .swap-content {
        margin-top: 15px;
        text-align: left;
    }
    
    .swap-options {
        max-height: 300px;
        overflow-y: auto;
        margin-top: 10px;
        border: 1px solid #eee;
        border-radius: 4px;
    }
    
    .swap-option {
        padding: 10px;
        border-bottom: 1px solid #eee;
        cursor: pointer;
        transition: background-color 0.2s;
    }
    
    .swap-option:last-child {
        border-bottom: none;
    }
    
    .swap-option:hover {
        background-color: #f5f7fa;
    }
    
    .swap-option.selected {
        background-color: #e3f2fd;
        border-left: 3px solid #1e3c72;
    }
    
    .swap-seed {
        color: #666;
        font-size: 0.8em;
        margin-left: 5px;
    }
    
    #swapDetails {
        background-color: #f5f7fa;
        padding: 10px;
        border-radius: 4px;
        margin-bottom: 10px;
    }
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const categorySelect = document.getElementById('categorySelect');
    const generateBracketBtn = document.getElementById('generateBracket');
    const bracketContainer = document.getElementById('bracket');

    categorySelect.addEventListener('change', function() {
        generateBracketBtn.disabled = !this.value;
    });

    generateBracketBtn.addEventListener('click', async function() {
        const category = categorySelect.value;
        if (!category) return;

        try {
            const response = await fetch(`/tournament/{{ tournament['Tournament Id'] }}/get_category_players/${category}`);
            const data = await response.json();
            
            if (data.error) {
                alert(data.error);
                return;
            }

            generateBracket(data.players);
        } catch (error) {
            console.error('Error:', error);
            alert('Error loading players');
        }
    });

    // Store bracket data globally for use in swapping
    let bracketData = {
        currentRounds: [],
        allPlayers: [],
        selectedRound: -1,
        selectedMatch: -1,
        selectedPlayerIndex: -1,
        selectedPlayer: null,
        targetPlayer: null
    };
    
    function generateBracket(players) {
        // Store all players for reference
        bracketData.allPlayers = players;
        
        // Sort players by seeding
        players.sort((a, b) => {
            const seedA = parseInt(a.seeding) || 999999;
            const seedB = parseInt(b.seeding) || 999999;
            return seedA - seedB;
        });

        // Pad with BYEs
        const numPlayers = players.length;
        const nextPowerOf2 = Math.pow(2, Math.ceil(Math.log2(numPlayers)));
        const numByes = nextPowerOf2 - numPlayers;
        const paddedPlayers = [...players];
        for (let i = 0; i < numByes; i++) {
            paddedPlayers.push({ name: 'BYE', seeding: 'BYE' });
        }

        // Get bracket order
        const bracketOrder = getBracketOrder(nextPowerOf2); // 1-based indices

        // Assign players to bracket positions
        const orderedPlayers = bracketOrder.map(idx => paddedPlayers[idx - 1]);

        // Generate first round matches
        const firstRoundMatches = [];
        for (let i = 0; i < orderedPlayers.length; i += 2) {
            firstRoundMatches.push([orderedPlayers[i], orderedPlayers[i + 1]]);
        }

        // Calculate total number of rounds
        const totalRounds = Math.log2(nextPowerOf2);

        // Generate all rounds
        const rounds = [firstRoundMatches];
        let currentRound = firstRoundMatches;

        // Generate subsequent rounds, handling BYEs
        for (let round = 1; round < totalRounds; round++) {
            const nextRound = [];
            for (let i = 0; i < currentRound.length; i += 2) {
                // For each pair of matches in the previous round
                let player1, player2;

                // Determine winner of match1
                const match1 = currentRound[i];
                if (match1[0].name === 'BYE') player1 = match1[1];
                else if (match1[1].name === 'BYE') player1 = match1[0];
                else player1 = { name: `Winner of Match ${i + 1}`, seeding: '' };

                // Determine winner of match2
                const match2 = currentRound[i + 1];
                if (match2[0].name === 'BYE') player2 = match2[1];
                else if (match2[1].name === 'BYE') player2 = match2[0];
                else player2 = { name: `Winner of Match ${i + 2}`, seeding: '' };

                nextRound.push([player1, player2]);
            }
            rounds.push(nextRound);
            currentRound = nextRound;
        }

        // Render bracket
        bracketContainer.innerHTML = '';
        rounds.forEach((round, roundIndex) => {
            const roundDiv = document.createElement('div');
            roundDiv.className = 'round';
            
            const roundTitle = document.createElement('div');
            roundTitle.className = 'round-title';
            roundTitle.textContent = getRoundLabel(roundIndex, rounds.length);
            roundDiv.appendChild(roundTitle);

            round.forEach((match, matchIndex) => {
                const matchDiv = document.createElement('div');
                matchDiv.className = 'match';
                matchDiv.id = `round-${roundIndex + 1}-match-${matchIndex + 1}`;
                
                match.forEach((player, playerIndex) => {
                    const playerDiv = document.createElement('div');
                    playerDiv.className = `player ${player.name === 'BYE' ? 'bye' : ''}`;
                    
                    // Create name span as clickable element
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = player.name;
                    
                    // Don't make "Winner of Match X" or BYE players clickable
                    if (player.name !== 'BYE' && !player.name.startsWith('Winner of Match')) {
                        nameSpan.addEventListener('click', function(e) {
                            e.stopPropagation();
                            showSwapPopup(roundIndex, matchIndex, playerIndex, player);
                        });
                    }
                    
                    playerDiv.appendChild(nameSpan);
                    
                    // Add seed if available
                    if (player.seeding && player.seeding !== 'BYE') {
                        const seedSpan = document.createElement('span');
                        seedSpan.className = 'seed';
                        seedSpan.textContent = `(${player.seeding})`;
                        playerDiv.appendChild(seedSpan);
                    }
                    
                    matchDiv.appendChild(playerDiv);
                });

                // Add the arrow icon that triggers the popup
                const arrowDiv = document.createElement('div');
                arrowDiv.className = 'match-arrow';
                arrowDiv.addEventListener('click', function(e) {
                    e.stopPropagation();
                    showScorePopup(roundIndex, matchIndex, match);
                });
                matchDiv.appendChild(arrowDiv);

                roundDiv.appendChild(matchDiv);
            });

            bracketContainer.appendChild(roundDiv);
        });
        
        // Store the rounds data for reference
        bracketData.currentRounds = rounds;
    }

    // Returns an array of indices for bracket seeding
    function getBracketOrder(n) {
        if (n === 1) return [1];
        const prev = getBracketOrder(n / 2);
        const res = [];
        for (let i = 0; i < prev.length; i++) {
            res.push(prev[i]);
            res.push(n + 1 - prev[i]);
        }
        return res;
    }

    function getRoundLabel(roundIndex, totalRounds) {
        const fromEnd = totalRounds - roundIndex;
        if (fromEnd === 1) return "Final";
        if (fromEnd === 2) return "Semi-Final";
        if (fromEnd === 3) return "Quarter-Final";
        if (fromEnd === 4) return "Round of 16";
        if (fromEnd === 5) return "Round of 32";
        if (fromEnd === 6) return "Round of 64";
        return `Round ${roundIndex + 1}`;
    }

    // Store match results
    const matchResults = {};
    
    // Modify your renderBracket function to show match results
    function renderBracket(rounds) {
        bracketData.currentRounds = rounds;
        
        const bracket = document.getElementById('bracket');
        bracket.innerHTML = '';
        
        if (!rounds || !Array.isArray(rounds) || rounds.length === 0) {
            bracket.innerHTML = '<div class="error">No bracket data available</div>';
            return;
        }
        
        rounds.forEach((round, roundIndex) => {
            const roundDiv = document.createElement('div');
            roundDiv.className = 'round';
            
            const roundTitle = document.createElement('div');
            roundTitle.className = 'round-title';
            roundTitle.textContent = getRoundLabel(roundIndex, rounds.length);
            roundDiv.appendChild(roundTitle);

            round.forEach((match, matchIndex) => {
                const matchDiv = document.createElement('div');
                matchDiv.className = 'match';
                matchDiv.id = `round-${roundIndex + 1}-match-${matchIndex + 1}`;
                
                // Get match results if available
                const matchId = `${roundIndex}-${matchIndex}`;
                const result = matchResults[matchId];
                
                match.forEach((player, playerIndex) => {
                    if (!player) player = { name: "Unknown", seeding: "" };
                    
                    const playerDiv = document.createElement('div');
                    playerDiv.className = "player";
                    
                    // Store player data for future reference
                    playerDiv.dataset.playerName = player.name;
                    if (player.seeding) {
                        playerDiv.dataset.playerSeeding = player.seeding;
                    }
                    
                    // Add winner class if this player won
                    if (result && result.winner && result.winner.name === player.name) {
                        playerDiv.classList.add("winner");
                    }
                    
                    if (player.name === "BYE") {
                        playerDiv.classList.add("bye");
                    }
                    
                    // Create clickable name span
                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = player.name;
                    
                    // Don't make "Winner of Match X" or BYE players clickable
                    if (player.name !== 'BYE' && !player.name.startsWith('Winner of Match')) {
                        nameSpan.addEventListener('click', function(e) {
                            e.stopPropagation();
                            showSwapPopup(roundIndex, matchIndex, playerIndex, player);
                        });
                    }
                    
                    playerDiv.appendChild(nameSpan);
                    
                    // Display seeding if available and not BYE
                    if (player.seeding && player.seeding !== 'BYE') {
                        const seedSpan = document.createElement('span');
                        seedSpan.className = 'seed';
                        seedSpan.textContent = `(${player.seeding})`;
                        playerDiv.appendChild(seedSpan);
                    }
                    
                    // Display scores if available
                    if (result && result.scores && result.scores[playerIndex]) {
                        const scoreSpan = document.createElement('span');
                        scoreSpan.className = 'score-display';
                        scoreSpan.textContent = result.scores[playerIndex].join('-');
                        playerDiv.appendChild(scoreSpan);
                    }
                    
                    matchDiv.appendChild(playerDiv);
                });
                
                // Add the arrow icon that triggers the popup
                const arrowDiv = document.createElement('div');
                arrowDiv.className = 'match-arrow';
                arrowDiv.addEventListener('click', function(e) {
                    e.stopPropagation();
                    showScorePopup(roundIndex, matchIndex, match);
                });
                matchDiv.appendChild(arrowDiv);
                
                roundDiv.appendChild(matchDiv);
            });
            
            bracket.appendChild(roundDiv);
        });
    }
    
    // Function to show score entry popup
    function showScorePopup(roundIndex, matchIndex, match) {
        const popup = document.getElementById('successPopup');
        const overlay = document.getElementById('popupOverlay');
        const matchDetails = document.getElementById('matchDetails');
        const scoreForm = document.getElementById('scoreForm');
        
        // Set hidden values
        document.getElementById('roundIndex').value = roundIndex;
        document.getElementById('matchIndex').value = matchIndex;
        
        // Get match results if available
        const matchId = `${roundIndex}-${matchIndex}`;
        const result = matchResults[matchId];
        
        // Set player names in the column headers
        const player1Name = match[0]?.name || 'Player 1';
        const player2Name = match[1]?.name || 'Player 2';
        
        document.getElementById('player1NameHeader').textContent = player1Name;
        document.getElementById('player2NameHeader').textContent = player2Name;
        
        // Check if either player is a BYE
        const hasBye = player1Name === 'BYE' || player2Name === 'BYE';
        
        // Handle BYE match differently
        if (hasBye) {
            // Disable score form
            scoreForm.classList.add('disabled');
            
            // Create a message about BYE advancement
            const byePlayer = player1Name === 'BYE' ? player2Name : player1Name;
            const byeMessage = document.createElement('div');
            byeMessage.className = 'bye-message';
            byeMessage.innerHTML = `<strong>${byePlayer}</strong> automatically advances to the next round due to a BYE.`;
            
            // Insert BYE message before the player columns
            const columnsElement = document.querySelector('.player-columns');
            scoreForm.insertBefore(byeMessage, columnsElement);
            
            // Auto-create the match result if not yet created
            if (!matchResults[matchId]) {
                // Determine winner (the non-BYE player)
                const winner = player1Name === 'BYE' ? match[1] : match[0];
                
                // Create default scores (11-0 for the winner)
                const scores = player1Name === 'BYE' 
                    ? [[0, 0, 0], [11, 11, 0]] 
                    : [[11, 11, 0], [0, 0, 0]];
                
                // Save result
                matchResults[matchId] = {
                    scores: scores,
                    winner: winner,
                    isBye: true
                };
            }
            
            // Fill in the fake scores for display
            const scores = matchResults[matchId].scores;
            document.getElementById('player1Game1').value = scores[0][0] || '';
            document.getElementById('player1Game2').value = scores[0][1] || '';
            document.getElementById('player1Game3').value = scores[0][2] || '';
            
            document.getElementById('player2Game1').value = scores[1][0] || '';
            document.getElementById('player2Game2').value = scores[1][1] || '';
            document.getElementById('player2Game3').value = scores[1][2] || '';
        } else {
            // Remove any existing BYE message
            const existingByeMessage = document.querySelector('.bye-message');
            if (existingByeMessage) {
                existingByeMessage.remove();
            }
            
            // Enable score form
            scoreForm.classList.remove('disabled');
            
            // Fill in existing scores if available
            if (result && result.scores) {
                document.getElementById('player1Game1').value = result.scores[0][0] || '';
                document.getElementById('player1Game2').value = result.scores[0][1] || '';
                document.getElementById('player1Game3').value = result.scores[0][2] || '';
                
                document.getElementById('player2Game1').value = result.scores[1][0] || '';
                document.getElementById('player2Game2').value = result.scores[1][1] || '';
                document.getElementById('player2Game3').value = result.scores[1][2] || '';
            } else {
                // Clear the form
                scoreForm.reset();
                
                // Reset hidden fields that got cleared
                document.getElementById('roundIndex').value = roundIndex;
                document.getElementById('matchIndex').value = matchIndex;
            }
        }
        
        // Get the round name
        const roundName = getRoundLabel(roundIndex, document.querySelectorAll('.round').length);
        
        // Set match details
        matchDetails.innerHTML = `<strong>${roundName} - Match ${matchIndex + 1}</strong>`;
        
        // Show popup and overlay
        popup.style.display = 'block';
        overlay.style.display = 'block';
    }
    
    // Update your score form submission handler
    document.getElementById('scoreForm').addEventListener('submit', function(e) {
        e.preventDefault();
        
        // Don't process if form is disabled (BYE match)
        if (this.classList.contains('disabled')) {
            // Just close the popup
            document.getElementById('successPopup').style.display = 'none';
            document.getElementById('popupOverlay').style.display = 'none';
            return;
        }
        
        const roundIndex = parseInt(document.getElementById('roundIndex').value);
        const matchIndex = parseInt(document.getElementById('matchIndex').value);
        const matchId = `${roundIndex}-${matchIndex}`;
        
        // Get the current match from the DOM to preserve player details including seeding
        const roundElement = document.querySelectorAll('.round')[roundIndex];
        const matchElement = roundElement.querySelectorAll('.match')[matchIndex];
        const playerElements = matchElement.querySelectorAll('.player');
        
        // Extract full player information, including seeding
        const match = [
            { 
                name: document.getElementById('player1NameHeader').textContent,
                seeding: playerElements[0].querySelector('.seed') ? 
                         playerElements[0].querySelector('.seed').textContent.replace(/[()]/g, '') : 
                         ''
            },
            { 
                name: document.getElementById('player2NameHeader').textContent,
                seeding: playerElements[1].querySelector('.seed') ? 
                         playerElements[1].querySelector('.seed').textContent.replace(/[()]/g, '') : 
                         ''
            }
        ];
        
        console.log("Match with seeding:", match);
        
        // Get scores
        const scores = [
            [
                parseInt(document.getElementById('player1Game1').value) || 0,
                parseInt(document.getElementById('player1Game2').value) || 0,
                parseInt(document.getElementById('player1Game3').value) || 0
            ],
            [
                parseInt(document.getElementById('player2Game1').value) || 0,
                parseInt(document.getElementById('player2Game2').value) || 0,
                parseInt(document.getElementById('player2Game3').value) || 0
            ]
        ];
        
        // Count wins for each player
        let player1Wins = 0;
        let player2Wins = 0;
        
        for (let i = 0; i < 3; i++) {
            if (scores[0][i] > scores[1][i]) player1Wins++;
            else if (scores[1][i] > scores[0][i]) player2Wins++;
        }
        
        // Determine winner
        let winner;
        if (player1Wins > player2Wins) {
            winner = match[0];
        } else if (player2Wins > player1Wins) {
            winner = match[1];
        } else {
            alert("Match must have a winner. Please ensure one player wins more games.");
            return;
        }
        
        // Save result with complete winner info
        matchResults[matchId] = {
            scores: scores,
            winner: winner
        };
        
        console.log(`Match ${matchId} winner with seeding:`, winner);
        
        // Close popup
        document.getElementById('successPopup').style.display = 'none';
        document.getElementById('popupOverlay').style.display = 'none';
        
        // Regenerate bracket to update next rounds
        regenerateBracket();
    });
    
    // Add this function to properly regenerate the bracket
    function regenerateBracket() {
        const category = document.getElementById('categorySelect').value;
        if (category) {
            fetch(`/tournament/{{ tournament_id }}/get_category_players/${category}`)
                .then(response => response.json())
                .then(data => {
                    if (data.players) {
                        generateAndRenderBracket(data.players);
                    }
                })
                .catch(error => {
                    console.error('Error fetching players:', error);
                });
        }
    }

    // Update your generateAndRenderBracket function
    function generateAndRenderBracket(players) {
        // Sort players by seeding
        players.sort((a, b) => {
            const seedA = parseInt(a.seeding) || 999999;
            const seedB = parseInt(b.seeding) || 999999;
            return seedA - seedB;
        });

        // Calculate number of rounds needed
        const numPlayers = players.length;
        const nextPowerOf2 = Math.pow(2, Math.ceil(Math.log2(numPlayers)));
        const numByes = nextPowerOf2 - numPlayers;

        // Pad with BYEs
        const paddedPlayers = [...players];
        for (let i = 0; i < numByes; i++) {
            paddedPlayers.push({ name: 'BYE', seeding: 'BYE' });
        }

        // Standard bracket seeding order
        function getBracketOrder(n) {
            if (n === 1) return [1];
            const prev = getBracketOrder(n / 2);
            const res = [];
            for (let i = 0; i < prev.length; i++) {
                res.push(prev[i]);
                res.push(n + 1 - prev[i]);
            }
            return res;
        }

        // Get bracket order for optimal seeding
        const bracketOrder = getBracketOrder(nextPowerOf2);
        const orderedPlayers = bracketOrder.map(idx => 
            (idx <= paddedPlayers.length) ? paddedPlayers[idx - 1] : 
            { name: 'BYE', seeding: 'BYE' }
        );

        // Generate first round matches
        const firstRoundMatches = [];
        for (let i = 0; i < orderedPlayers.length; i += 2) {
            firstRoundMatches.push([orderedPlayers[i], orderedPlayers[i + 1]]);
        }

        // Calculate total number of rounds
        const totalRounds = Math.log2(nextPowerOf2);

        // Generate all rounds
        const rounds = [firstRoundMatches];
        let currentRound = firstRoundMatches;
        
        // Generate subsequent rounds, handling BYEs and match results
        for (let round = 1; round < totalRounds; round++) {
            const nextRound = [];
            for (let i = 0; i < currentRound.length; i += 2) {
                // For each pair of matches in the previous round
                let player1, player2;
                const matchId1 = `${round-1}-${i}`;
                const matchId2 = `${round-1}-${i+1}`;

                // Determine winner of match1
                const match1 = currentRound[i];
                if (matchResults[matchId1]) {
                    // Use the saved winner from match results (which includes seeding)
                    player1 = matchResults[matchId1].winner;
                    console.log(`Using saved winner for match ${matchId1}: ${player1.name} (Seed: ${player1.seeding})`);
                } else if (match1[0].name === 'BYE') {
                    // Auto-advance the non-BYE player WITH seeding
                    player1 = match1[1];
                    console.log(`Auto-advancing for BYE in match ${matchId1}: ${player1.name} (Seed: ${player1.seeding})`);
                    
                    // Auto-create result for BYE match if not exists
                    if (!matchResults[matchId1]) {
                        matchResults[matchId1] = {
                            scores: [[0, 0, 0], [11, 11, 0]],
                            winner: match1[1], // Includes seeding
                            isBye: true
                        };
                    }
                } else if (match1[1].name === 'BYE') {
                    // Auto-advance the non-BYE player WITH seeding
                    player1 = match1[0];
                    console.log(`Auto-advancing for BYE in match ${matchId1}: ${player1.name} (Seed: ${player1.seeding})`);
                    
                    // Auto-create result for BYE match if not exists
                    if (!matchResults[matchId1]) {
                        matchResults[matchId1] = {
                            scores: [[11, 11, 0], [0, 0, 0]],
                            winner: match1[0], // Includes seeding
                            isBye: true
                        };
                    }
                } else {
                    // No result yet, use placeholder with no seeding
                    player1 = { name: `Winner of Match ${i + 1}`, seeding: '' };
                }

                // Determine winner of match2 (same logic as above)
                const match2 = currentRound[i + 1];
                if (matchResults[matchId2]) {
                    player2 = matchResults[matchId2].winner;
                    console.log(`Using saved winner for match ${matchId2}: ${player2.name} (Seed: ${player2.seeding})`);
                } else if (match2[0].name === 'BYE') {
                    player2 = match2[1];
                    console.log(`Auto-advancing for BYE in match ${matchId2}: ${player2.name} (Seed: ${player2.seeding})`);
                    
                    // Auto-create result for BYE match if not exists
                    if (!matchResults[matchId2]) {
                        matchResults[matchId2] = {
                            scores: [[0, 0, 0], [11, 11, 0]],
                            winner: match2[1], // Includes seeding
                            isBye: true
                        };
                    }
                } else if (match2[1].name === 'BYE') {
                    player2 = match2[0];
                    console.log(`Auto-advancing for BYE in match ${matchId2}: ${player2.name} (Seed: ${player2.seeding})`);
                    
                    // Auto-create result for BYE match if not exists
                    if (!matchResults[matchId2]) {
                        matchResults[matchId2] = {
                            scores: [[11, 11, 0], [0, 0, 0]],
                            winner: match2[0], // Includes seeding
                            isBye: true
                        };
                    }
                } else {
                    player2 = { name: `Winner of Match ${i + 2}`, seeding: '' };
                }

                nextRound.push([player1, player2]);
            }
            rounds.push(nextRound);
            currentRound = nextRound;
        }

        // Render the updated bracket with all match results
        renderBracket(rounds);
        
        // Add debugging information
        console.log("Generated bracket with match results:", { rounds, matchResults });
    }

    // Replace your existing closePopup event handler with this:
    document.getElementById('closePopup').addEventListener('click', function(e) {
        e.preventDefault(); // Prevent any default action
        
        // Remove any existing BYE message (to prepare for next popup)
        const existingByeMessage = document.querySelector('.bye-message');
        if (existingByeMessage) {
            existingByeMessage.remove();
        }
        
        // Hide popup and overlay
        document.getElementById('successPopup').style.display = 'none';
        document.getElementById('popupOverlay').style.display = 'none';
    });
    
    // Also update the overlay click handler to handle the BYE message
    document.getElementById('popupOverlay').addEventListener('click', function() {
        // Remove any existing BYE message
        const existingByeMessage = document.querySelector('.bye-message');
        if (existingByeMessage) {
            existingByeMessage.remove();
        }
        
        // Hide popup and overlay
        document.getElementById('successPopup').style.display = 'none';
        document.getElementById('popupOverlay').style.display = 'none';
    });

    // Add function to show the swap popup
    function showSwapPopup(roundIndex, matchIndex, playerIndex, player) {
        const popup = document.getElementById('swapPopup');
        const overlay = document.getElementById('popupOverlay');
        const swapDetails = document.getElementById('swapDetails');
        const swapOptions = document.getElementById('swapOptions');
        
        // Store selected player info
        bracketData.selectedRound = roundIndex;
        bracketData.selectedMatch = matchIndex;
        bracketData.selectedPlayerIndex = playerIndex;
        bracketData.selectedPlayer = player;
        bracketData.targetPlayer = null;
        
        // Show player details
        swapDetails.innerHTML = `Swapping: <strong>${player.name}</strong>${player.seeding ? ` (Seed: ${player.seeding})` : ''}`;
        
        // Get all players from the same round
        const playersInRound = [];
        bracketData.currentRounds[roundIndex].forEach((match, mIdx) => {
            match.forEach((p, pIdx) => {
                // Don't include BYE players, "Winner of Match X", or the selected player
                if (p.name !== 'BYE' && 
                    !p.name.startsWith('Winner of Match') && 
                    !(mIdx === matchIndex && pIdx === playerIndex)) {
                    playersInRound.push({
                        player: p,
                        matchIndex: mIdx,
                        playerIndex: pIdx
                    });
                }
            });
        });
        
        // Generate swap options
        swapOptions.innerHTML = '';
        playersInRound.forEach(option => {
            const optionDiv = document.createElement('div');
            optionDiv.className = 'swap-option';
            optionDiv.innerHTML = `
                ${option.player.name}
                ${option.player.seeding ? `<span class="swap-seed">(Seed: ${option.player.seeding})</span>` : ''}
            `;
            
            // Add click handler to select this player
            optionDiv.addEventListener('click', function() {
                // Remove selected class from all options
                document.querySelectorAll('.swap-option').forEach(el => {
                    el.classList.remove('selected');
                });
                
                // Add selected class to this option
                this.classList.add('selected');
                
                // Store target player
                bracketData.targetPlayer = {
                    player: option.player,
                    matchIndex: option.matchIndex,
                    playerIndex: option.playerIndex
                };
            });
            
            swapOptions.appendChild(optionDiv);
        });
        
        // Show popup and overlay
        popup.style.display = 'block';
        overlay.style.display = 'block';
    }
    
    // Add event listeners for the swap popup
    document.getElementById('closeSwapPopup').addEventListener('click', function() {
        document.getElementById('swapPopup').style.display = 'none';
        document.getElementById('popupOverlay').style.display = 'none';
    });
    
    document.getElementById('confirmSwap').addEventListener('click', function() {
        if (!bracketData.targetPlayer) {
            alert('Please select a player to swap with.');
            return;
        }
        
        // Perform the swap
        const { selectedRound, selectedMatch, selectedPlayerIndex, targetPlayer } = bracketData;
        
        // Get current match
        const currentMatch = bracketData.currentRounds[selectedRound][selectedMatch];
        
        // Get target match
        const targetMatch = bracketData.currentRounds[selectedRound][targetPlayer.matchIndex];
        
        // Store temporary references to the players
        const playerA = {...currentMatch[selectedPlayerIndex]};
        const playerB = {...targetMatch[targetPlayer.playerIndex]};
        
        // Swap the players
        currentMatch[selectedPlayerIndex] = playerB;
        targetMatch[targetPlayer.playerIndex] = playerA;
        
        // Close popup
        document.getElementById('swapPopup').style.display = 'none';
        document.getElementById('popupOverlay').style.display = 'none';
        
        // Clear any match results that involve these players
        const currentMatchId = `${selectedRound}-${selectedMatch}`;
        const targetMatchId = `${selectedRound}-${targetPlayer.matchIndex}`;
        
        // Delete results for these matches as they are no longer valid
        if (matchResults[currentMatchId]) {
            delete matchResults[currentMatchId];
        }
        
        if (matchResults[targetMatchId]) {
            delete matchResults[targetMatchId];
        }
        
        // Re-render the bracket
        renderBracket(bracketData.currentRounds);
        
        console.log(`Swapped ${playerA.name} with ${playerB.name}`);
    });
    
    // Also let the overlay close the swap popup
    document.getElementById('popupOverlay').addEventListener('click', function() {
        if (document.getElementById('swapPopup').style.display === 'block') {
            document.getElementById('swapPopup').style.display = 'none';
            document.getElementById('popupOverlay').style.display = 'none';
        } else if (document.getElementById('successPopup').style.display === 'block') {
            // Remove any existing BYE message
            const existingByeMessage = document.querySelector('.bye-message');
            if (existingByeMessage) {
                existingByeMessage.remove();
            }
            
            // Hide popup and overlay
            document.getElementById('successPopup').style.display = 'none';
            document.getElementById('popupOverlay').style.display = 'none';
        }
    });
});
</script>
{% endblock %}
