<!DOCTYPE html>
<html>
<head>
    <title>{{ tournament['Tournament Name'] }}</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link href="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/css/select2.min.css" rel="stylesheet" />
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/select2@4.1.0-rc.0/dist/js/select2.min.js"></script>
    <script src="{{ url_for('static', filename='js/clash_resolution.js') }}"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Roboto', sans-serif; }
        body { min-height: 100vh; background: #f0f2f5; display: flex; flex-direction: column; }
        .container { flex: 1; display: flex; flex-direction: column; }

        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 20px 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            margin-bottom: 20px;
        }
        .header .logo {
            position: absolute;
            left: 24px;
            height: 40px;
            width: auto;
        }
        .header h1 {
            margin: 0;
            font-size: 1.8em;
            font-weight: 500;
            text-align: center;
        }
        .tournament-subheader {
            text-align: center;
            color: #1e3c72;
            font-size: 1.5em;
            margin: 10px 0 8px 0;
            padding: 0 20px;
            font-weight: 500;
        }

        .back-button {
            position: absolute;
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
            color: white;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 500;
        }

        .content {
            flex: 1;
            padding: 3vh 24px;
            max-width: 1000px;
            margin: 0 auto;
            width: 100%;
        }

        .detail-card {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .detail-section {
            margin-bottom: 20px;
        }

        .section-title {
            color: #1e3c72;
            font-size: 1.2em;
            font-weight: 500;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 2px solid #e0e0e0;
        }

        .detail-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 16px;
        }

        .detail-item {
            margin-bottom: 12px;
        }

        .detail-label {
            font-weight: 500;
            color: #666;
            margin-bottom: 4px;
        }

        .detail-value {
            color: #333;
        }

        .status-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.9em;
            font-weight: 500;
            text-align: center;
            margin-left: 12px;
        }
        .status-badge.upcoming {
            background: #2196F3;
            color: white;
        }
        .status-badge.in-progress {
            background: #4CAF50;
            color: white;
        }
        .status-badge.completed {
            background: #9E9E9E;
            color: white;
        }

        .prize-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 8px 0;
        }
        .prize-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .prize-label {
            font-weight: 500;
            color: #64748b;
            min-width: 100px;
        }
        .prize-value {
            color: #1e3c72;
        }

        .categories-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 12px;
        }

        .categories-table th,
        .categories-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid #e0e0e0;
        }

        .categories-table th {
            background: #f5f5f5;
            font-weight: 500;
            color: #1e3c72;
        }

        .tournament-section {
            margin-bottom: 2rem;
            padding: 1.5rem;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .logo-section {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 1rem;
        }

        .logo-container {
            width: 200px;
            height: 200px;
            border: 1px solid #ddd;
            border-radius: 4px;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f8f9fa;
        }

        .tournament-logo {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        .logo-container .detail-label {
            color: #1e3c72;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        @media (max-width: 768px) {
            .detail-grid {
                grid-template-columns: 1fr;
            }
            .content {
                padding: 2vh 16px;
            }
            .categories-table {
                display: block;
                overflow-x: auto;
            }
            .header {
                padding: 15px 16px;
            }
            .header .logo {
                left: 16px;
                height: 30px;
            }
            .header h1 {
                font-size: 1.5em;
            }
        }

        /* Tab Styles */
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }

        .tab-header {
            display: flex;
            gap: 2px;
            background: #f8fafc;
            padding: 4px;
            border-radius: 8px;
            margin-bottom: 24px;
        }

        .tab-button {
            padding: 12px 24px;
            border: none;
            background: none;
            color: #64748b;
            font-weight: 500;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
            flex: 1;
            text-align: center;
        }

        .tab-button:hover {
            color: #1e3c72;
            background: rgba(30, 60, 114, 0.05);
        }

        .tab-button.active {
            background: #1e3c72;
            color: white;
        }

        .tab-button i {
            margin-right: 8px;
        }

        /* Registration Styles */
        .registration-options {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        .registration-button {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            padding: 20px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            color: #1e3c72;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.2s;
        }

        .registration-button:hover {
            background: #1e3c72;
            color: white;
            transform: translateY(-2px);
        }

        /* Entries Styles */
        .entries-container {
            margin-top: 20px;
        }

        .category-section {
            margin-bottom: 2rem;
        }

        .category-section h3 {
            color: #2c3e50;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid #3498db;
        }

        .category-grid {
            display: flex;
            flex-wrap: nowrap;
            gap: 0.5rem;
            overflow-x: auto;
            padding-bottom: 1rem;
        }

        .category-box {
            flex: 0 0 150px;
            min-width: 150px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 0.5rem;
        }

        .category-box h4 {
            color: #2c3e50;
            margin-bottom: 0.5rem;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid #eee;
            font-size: 0.9rem;
        }

        .player-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .player-list li {
            padding: 0.25rem;
            border-bottom: 1px solid #eee;
            font-size: 0.8rem;
        }

        .player-list li:last-child {
            border-bottom: none;
        }

        .player-list li .seeding {
            font-weight: bold;
            color: #3498db;
            margin-right: 0.25rem;
            font-size: 0.8rem;
        }

        .player-list li small {
            font-size: 0.7rem;
        }

        /* Add horizontal scrollbar styling */
        .category-grid::-webkit-scrollbar {
            height: 4px;
        }

        .category-grid::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 2px;
        }

        .category-grid::-webkit-scrollbar-thumb {
            background: #3498db;
            border-radius: 2px;
        }

        .category-grid::-webkit-scrollbar-thumb:hover {
            background: #2980b9;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .category-box {
                flex: 0 0 120px;
                min-width: 120px;
            }
        }

        /* Schedule Styles */
        .schedule-container {
            margin-top: 20px;
        }

        .schedule-filters {
            display: flex;
            gap: 16px;
            margin-bottom: 20px;
        }

        .filter-select {
            padding: 8px 16px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            background: white;
            color: #1e3c72;
            min-width: 200px;
        }

        .schedule-timeline {
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
        }

        /* Draws Styles */
        .draws-container {
            margin-top: 20px;
        }

        .draws-filters {
            margin-bottom: 20px;
        }

        .draws-content {
            background: #f8fafc;
            border-radius: 12px;
            padding: 20px;
            min-height: 200px;
        }

        .loading {
            text-align: center;
            color: #64748b;
            padding: 20px;
        }

        @media (max-width: 768px) {
            .registration-options {
                flex-direction: column;
            }

            .entries-grid {
                grid-template-columns: 1fr;
            }

            .schedule-filters {
                flex-direction: column;
            }

            .filter-select {
                width: 100%;
            }
        }

        /* Manage Tab Styles */
        .manage-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .manage-button {
            display: flex;
            align-items: flex-start;
            gap: 16px;
            padding: 20px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            color: #1e3c72;
            text-decoration: none;
            transition: all 0.2s;
        }

        .manage-button:hover {
            background: #1e3c72;
            color: white;
            transform: translateY(-2px);
        }

        .manage-button i {
            font-size: 24px;
            padding: 12px;
            background: rgba(30, 60, 114, 0.1);
            border-radius: 8px;
        }

        .manage-button:hover i {
            background: rgba(255, 255, 255, 0.2);
        }

        .manage-button-content {
            flex: 1;
        }

        .manage-button-content h3 {
            margin: 0 0 8px 0;
            font-size: 1.1em;
        }

        .manage-button-content p {
            margin: 0;
            font-size: 0.9em;
            opacity: 0.8;
        }

        @media (max-width: 768px) {
            .manage-options {
                grid-template-columns: 1fr;
            }
        }

        /* Update subheader and logo section styles */
        .tournament-header-section {
            padding: 10px 24px;
            margin: 10px auto;
            max-width: 1200px;
            display: flex;
            justify-content: center;
        }

        .tournament-logos {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
        }

        .tournament-logo-small {
            height: 40px;
            width: auto;
            object-fit: contain;
            border-radius: 4px;
            border: 1px solid #ddd;
            padding: 2px;
            background: white;
        }

        @media (max-width: 768px) {
            .tournament-header-section {
                padding: 10px 16px;
            }

            .tournament-logo-small {
                height: 30px;
            }
        }

        /* Add new styles for logo section */
        .tournament-logos-section {
            padding: 20px 24px;
            margin: 0 auto;
            max-width: 1200px;
            display: flex;
            justify-content: center;
        }

        .tournament-logos {
            display: flex;
            gap: 20px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        .tournament-logo {
            height: 60px;
            width: auto;
            object-fit: contain;
            border-radius: 8px;
            border: 1px solid #ddd;
            padding: 5px;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        @media (max-width: 768px) {
            .tournament-logos-section {
                padding: 15px 16px;
            }

            .tournament-logos {
                gap: 15px;
            }

            .tournament-logo {
                height: 45px;
            }
        }

        .registration-form {
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            padding: 24px;
            margin-top: 20px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            color: #333;
            font-weight: 500;
        }

        .form-group.required label:after {
            content: " ✓";
            color: #1e3c72;
            font-weight: bold;
        }

        .form-group.required label {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .form-control {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .form-control:focus {
            border-color: #1e3c72;
            outline: none;
            box-shadow: 0 0 0 2px rgba(30,60,114,0.2);
        }

        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .search-result-item {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
        }

        .search-result-item:hover {
            background: #f5f5f5;
        }

        .selected-player {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border: 1px solid #e9ecef;
        }

        .fee-summary {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            border: 1px solid #e9ecef;
        }

        .fee-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .fee-total {
            font-weight: bold;
            border-top: 1px solid #ddd;
            padding-top: 10px;
            margin-top: 10px;
        }

        .submit-button {
            padding: 12px 24px;
            background: #1e3c72;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            margin-top: 20px;
            width: 100%;
        }

        .submit-button:hover {
            background: #2a5298;
        }

        .submit-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .success-message {
            background-color: #d4edda;
            color: #155724;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid #c3e6cb;
            border-radius: 4px;
            font-size: 16px;
            text-align: center;
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 20px;
            animation: flash 0.5s ease-in-out;
        }

        @keyframes flash {
            0% { opacity: 0; transform: translateY(-10px); }
            50% { opacity: 1; transform: translateY(0); }
            100% { opacity: 1; transform: translateY(0); }
        }

        /* Category Checkbox Styles */
        .category-checkbox {
            margin-bottom: 12px;
            padding: 12px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            transition: all 0.2s ease;
            background: #f8fafc;
        }

        .category-checkbox:hover {
            background: #f1f5f9;
            border-color: #cbd5e1;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        .category-checkbox input[type="checkbox"] {
            display: none;
        }

        .category-checkbox label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-weight: 500;
            color: #1e3c72;
            margin: 0;
            padding-left: 32px;
            position: relative;
            user-select: none;
        }

        .category-checkbox label:before {
            content: '';
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border: 2px solid #cbd5e1;
            border-radius: 4px;
            background: white;
            transition: all 0.2s ease;
        }

        .category-checkbox label:after {
            content: '✓';
            position: absolute;
            left: 3px;
            top: 50%;
            transform: translateY(-50%) scale(0);
            color: #ffffff;
            font-size: 14px;
            font-weight: bold;
            transition: transform 0.2s ease;
            text-shadow: 0 1px 1px rgba(0,0,0,0.2);
        }

        .category-checkbox input[type="checkbox"]:checked + label:before {
            background: #1e3c72;
            border-color: #1e3c72;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
        }

        .category-checkbox input[type="checkbox"]:checked + label:after {
            transform: translateY(-50%) scale(1);
            color: #ffffff;
        }

        .category-checkbox input[type="checkbox"]:disabled + label {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .category-checkbox input[type="checkbox"]:disabled + label:before {
            background: #e2e8f0;
            border-color: #cbd5e1;
        }

        #categoryCheckboxes {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 12px;
            margin-top: 12px;
        }

        @media (max-width: 768px) {
            #categoryCheckboxes {
                grid-template-columns: 1fr;
            }
        }

        .registration-button-container {
            margin: 20px 0;
            text-align: center;
            padding: 0 20px;
        }

        .registration-button-container .submit-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 24px;
            background: #1e3c72;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 500;
            transition: all 0.2s ease;
            max-width: 300px;
            width: 100%;
            margin: 0 auto;
        }

        .registration-button-container .submit-button:hover {
            background: #2a5298;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .registration-button-container .submit-button i {
            font-size: 18px;
        }

        .tab-button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            background: #f1f1f1 !important;
            color: #999 !important;
            pointer-events: none;
        }

        .tab-button:disabled:hover {
            background: #f1f1f1 !important;
            color: #999 !important;
            transform: none !important;
        }

        .error-message i {
            margin-right: 8px;
        }

        .registration-closed-message {
            background-color: #f8d7da;
            color: #721c24;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            font-size: 16px;
            border: 1px solid #f5c6cb;
        }

        /* Countdown Timer Styles */
        .countdown-container {
            max-width: 300px;
            margin: 0;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .countdown-item {
            text-align: center;
            background: white;
            padding: 0.25rem;
            border-radius: 4px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            min-width: 45px;
        }

        .countdown-separator {
            font-size: 1.25rem;
            font-weight: bold;
            color: #2563eb;
            margin-top: -0.25rem;
        }

        .countdown-value {
            font-size: 1.25rem;
            font-weight: bold;
            color: #2563eb;
            margin-bottom: 0.1rem;
        }

        .countdown-label {
            font-size: 0.65rem;
            color: #6b7280;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Add these styles to your existing CSS */
        .status-message {
            padding: 10px 15px;
            margin: 15px 0;
            border-radius: 5px;
            display: none;
        }

        .status-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .status-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .shuffle-counter {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            font-size: 18px;
            z-index: 1000;
            display: none;
        }

        .stop-shuffle-btn {
            background-color: #dc3545;
            color: white;
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s, transform 0.1s;
        }

        .stop-shuffle-btn:hover {
            background-color: #c82333;
            transform: translateY(-1px);
        }

        .stop-shuffle-btn:active {
            transform: translateY(1px);
        }

        @keyframes highlight {
            0% { background-color: #f9fbfd; }
            50% { background-color: #d4e5ff; }
            100% { background-color: #f9fbfd; }
        }

        .highlight-animation {
            animation: highlight 0.05s ease;
        }

        .rank-cell {
            text-align: center;
            font-weight: 600;
            background-color: #f0f5ff;
        }

        .editable-input {
            border: 1px solid #b0b8c9;
            border-radius: 4px;
            padding: 6px 8px;
            font-size: 1em;
            background: #fff;
            color: #1e3c72;
            box-sizing: border-box;
        }

        .bracket-controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .form-control {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            min-width: 200px;
        }

        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }

        .btn-primary {
            background: #1e3c72;
            color: white;
        }

        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .bracket-container {
            overflow-x: auto;
            padding: 20px 0;
            background: #f8f9fa;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .bracket {
            display: flex;
            flex-direction: row;
            gap: 50px;
            min-width: max-content;
            padding: 20px;
            position: relative;
            align-items: flex-start;
        }

        .round {
            display: flex;
            flex-direction: column;
            position: relative;
            align-items: center;
            width: 220px;
            min-width: 220px;
        }

        .round:first-child {
            align-items: center;
        }

        .round:not(:first-child) {
            align-items: center;
            justify-content: flex-start;
            position: relative;
        }

        /* Perfect alignment for subsequent rounds */
        .round:nth-child(2) {
            margin-top: 0;
        }

        .round:nth-child(3) {
            margin-top: 0;
        }

        .round:nth-child(4) {
            margin-top: 0;
        }


        .match {
            background: white;
            border: 2px solid #1e3c72;
            border-radius: 8px;
            padding: 12px;
            width: 200px;
            min-width: 200px;
            max-width: 200px;
            position: relative;
            height: 70px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 2;
            flex-shrink: 0;
        }

        .match:hover {
            box-shadow: 0 4px 12px rgba(30, 60, 114, 0.2);
            transform: translateY(-2px);
        }
        
        /* Connecting lines between rounds */
        .bracket {
            position: relative;
        }
        
        .connecting-line {
            position: absolute;
            background: #1e3c72;
            z-index: 1;
            pointer-events: none;
        }
        
        .horizontal-line {
            height: 2px;
        }
        
        .vertical-line {
            width: 2px;
        }
        
        /* Match Results Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }
        
        .modal-content {
            background-color: #fefefe;
            margin: 2% auto;
            padding: 20px;
            border: 1px solid #888;
            border-radius: 8px;
            width: 90%;
            max-width: 700px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            position: relative;
        }
        
        @media (max-width: 768px) {
            .modal-content {
                width: 95%;
                margin: 1% auto;
                padding: 15px;
            }
        }
        
        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            position: absolute;
            top: 10px;
            right: 15px;
            z-index: 1001;
        }
        
        .close:hover {
            color: #000;
        }
        
        .results-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }
        
        .results-table th,
        .results-table td {
            border: 1px solid #ddd;
            padding: 12px;
            text-align: center;
        }
        
        .results-table th {
            background-color: #1e3c72;
            color: white;
            font-weight: bold;
        }
        
        .results-table tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        
        .score-input {
            width: 60px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            text-align: center;
            font-size: 14px;
        }
        
        .player-name {
            font-weight: bold;
            color: #1e3c72;
        }
        
        .modal-buttons {
            margin-top: 20px;
            text-align: right;
        }
        
        .btn-save {
            background-color: #28a745;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-left: 10px;
        }
        
        .btn-cancel {
            background-color: #6c757d;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .btn-save:hover {
            background-color: #218838;
        }
        
        .btn-cancel:hover {
            background-color: #5a6268;
        }
        
        /* Match info above match box */
        .match-info-above {
            text-align: center;
            margin-bottom: 12px;
            font-weight: bold;
            color: #1e3c72;
            font-size: 12px;
            display: block;
        }
        



        /* Round titles */
        .round-title {
            font-weight: bold;
            font-size: 16px;
            color: #1e3c72;
            text-align: center;
            margin-bottom: 20px;
            padding: 8px 16px;
            background: linear-gradient(135deg, #1e3c72, #2a4f9e);
            color: white;
            border-radius: 6px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            width: 100%;
            max-width: 200px;
            position: relative;
            z-index: 10;
            flex-shrink: 0;
        }

        /* Player styling */
        .player {
            display: flex;
            justify-content: space-between;
            align-items: center;
            min-height: 24px;
        }

        .player.bye {
            opacity: 0.6;
            font-style: italic;
        }

        .seed {
            font-size: 0.85em;
            color: #666;
            font-weight: 400;
        }


        /* Responsive design */
        @media (max-width: 768px) {
            .bracket {
                gap: 30px;
            }
            
            .match {
                width: 160px;
                min-width: 160px;
                max-width: 160px;
                height: 60px;
            }
        }

        .match-arrow {
            position: absolute;
            right: -12px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background-color: #1e3c72;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 10;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: transform 0.2s, background-color 0.2s;
        }
        
        .match-arrow:hover {
            transform: translateY(-50%) scale(1.1);
            background-color: #2a4f9e;
        }
        
        .match-arrow::after {
            content: '→';
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        .success-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            text-align: center;
            min-width: 350px;
            max-width: 90%;
        }
        
        .success-popup h3 {
            margin-top: 0;
            color: #1e3c72;
            margin-bottom: 15px;
        }
        
        .popup-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }
        
        .score-form {
            margin-top: 15px;
            text-align: left;
        }
        
        .player-columns {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        
        .player-column {
            flex-basis: 45%;
            text-align: center;
            font-weight: 500;
            padding: 5px;
            background-color: #f5f7fa;
            border-radius: 4px;
            color: #1e3c72;
        }

        .score-row {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .score-row label {
            flex-basis: 60px;
            font-weight: 500;
        }
        
        .score-inputs {
            display: flex;
            justify-content: space-between;
            flex-grow: 1;
        }

        .swap-popup {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            text-align: center;
            min-width: 350px;
            max-width: 90%;
        }
        
        .swap-popup h3 {
            margin-top: 0;
            color: #1e3c72;
            margin-bottom: 15px;
        }
        
        .swap-content {
            margin-top: 15px;
            text-align: left;
        }
        
        .swap-options {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
            border: 1px solid #eee;
            border-radius: 4px;
        }
        
        .swap-option {
            padding: 10px;
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        .swap-option:last-child {
            border-bottom: none;
        }
        
        .swap-option:hover {
            background-color: #f5f7fa;
        }
        
        .swap-option.selected {
            background-color: #e3f2fd;
            border-left: 3px solid #1e3c72;
        }
        
        .swap-seed {
            color: #666;
            font-size: 0.8em;
            margin-left: 5px;
        }
        
        #swapDetails {
            background-color: #f5f7fa;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 10px;
        }

        .readonly-cell {
            pointer-events: none;
            background-color: #f8f9fa;
            user-select: none;
        }

        /* Clash Resolution Styles */
        .clash-status {
            background-color: #f8d7da !important;
            color: #721c24 !important;
            border: 1px solid #f5c6cb;
        }

        .no-clash-status {
            background-color: #d4edda !important;
            color: #155724 !important;
            border: 1px solid #c3e6cb;
        }

        /* Seed Range Colors */
        .seed-range-top {
            background-color: #fff3cd !important;
            border-left: 4px solid #ffc107;
        }

        .seed-range-upper {
            background-color: #d1ecf1 !important;
            border-left: 4px solid #17a2b8;
        }

        .seed-range-mid {
            background-color: #d4edda !important;
            border-left: 4px solid #28a745;
        }

        .seed-range-lower {
            background-color: #f8d7da !important;
            border-left: 4px solid #dc3545;
        }

        .seed-range-unseeded {
            background-color: #f5f5f5 !important;
            border-left: 4px solid #9e9e9e;
        }

        /* Seed Range Colors - Dynamic classes based on seeding_ranges.json */
        .seed-range-top-seeds {
            background-color: #fff3cd !important;
            border-left: 4px solid #ffc107;
        }

        .seed-range-upper-seeds {
            background-color: #e3f2fd !important;
            border-left: 4px solid #2196f3;
        }

        .seed-range-mid-seeds {
            background-color: #e8f5e8 !important;
            border-left: 4px solid #4caf50;
        }

        .seed-range-lower-seeds {
            background-color: #ffebee !important;
            border-left: 4px solid #f44336;
        }

        .seed-range-unseeded {
            background-color: #f5f5f5 !important;
            border-left: 4px solid #9e9e9e;
        }

        /* Override old classes with new distinct colors */
        .seed-range-top-seeds {
            background-color: #fff3cd !important;
            border-left: 4px solid #ffc107;
        }

        .seed-range-upper-seeds {
            background-color: #e3f2fd !important;
            border-left: 4px solid #2196f3;
        }

        .seed-range-mid-seeds {
            background-color: #e8f5e8 !important;
            border-left: 4px solid #4caf50;
        }

        .seed-range-lower-seeds {
            background-color: #ffebee !important;
            border-left: 4px solid #f44336;
        }

        /* Ensure these colors are applied with higher specificity */
        tr.seed-range-top-seeds {
            background-color: #fff3cd !important;
            border-left: 4px solid #ffc107;
        }

        tr.seed-range-upper-seeds {
            background-color: #e3f2fd !important;
            border-left: 4px solid #2196f3;
        }

        tr.seed-range-mid-seeds {
            background-color: #e8f5e8 !important;
            border-left: 4px solid #4caf50;
        }

        tr.seed-range-lower-seeds {
            background-color: #ffebee !important;
            border-left: 4px solid #f44336;
        }

        tr.seed-range-unseeded {
            background-color: #f5f5f5 !important;
            border-left: 4px solid #9e9e9e;
        }

        /* Seeding Clash Styles */
        .seeding-clash-row {
            background-color: #ffc107 !important;
            color: #000 !important;
            font-weight: bold;
        }

        /* Seeding Clash Highlighting */
        .seeding-clash {
            background-color: #ffebee !important;
            border: 2px solid #f44336 !important;
            box-shadow: 0 0 5px rgba(244, 67, 54, 0.5) !important;
        }

        .seeding-clash td {
            color: #d32f2f !important;
            font-weight: bold !important;
        }

        /* Clash Summary Styles */
        .clash-summary {
            background-color: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            padding: 15px;
            margin-top: 20px;
            margin-bottom: 20px;
        }

        .clash-summary h4 {
            color: #856404;
            margin-top: 0;
            margin-bottom: 10px;
        }

        .clash-item {
            background-color: #fff;
            border: 1px solid #ffeaa7;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 8px;
        }

        .clash-item strong {
            color: #d32f2f;
        }

        .resolve-clash-btn {
            background-color: #4caf50;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin-left: 10px;
            font-size: 0.8em;
        }

        .resolve-clash-btn:hover {
            background-color: #45a049;
        }

        /* Generic Seed Range Colors - Works with any seeding range descriptions */
        /* These classes will be applied dynamically based on the range index */
        .seed-range-0 { background-color: #fff3cd !important; border-left: 4px solid #ffc107 !important; }
        .seed-range-1 { background-color: #e3f2fd !important; border-left: 4px solid #2196f3 !important; }
        .seed-range-2 { background-color: #e8f5e8 !important; border-left: 4px solid #4caf50 !important; }
        .seed-range-3 { background-color: #ffebee !important; border-left: 4px solid #f44336 !important; }
        .seed-range-4 { background-color: #f3e5f5 !important; border-left: 4px solid #9c27b0 !important; }
        .seed-range-5 { background-color: #fff8e1 !important; border-left: 4px solid #ff9800 !important; }
        .seed-range-6 { background-color: #f5f5f5 !important; border-left: 4px solid #9e9e9e !important; }
        .seed-range-7 { background-color: #e0f2f1 !important; border-left: 4px solid #009688 !important; }
        .seed-range-8 { background-color: #fce4ec !important; border-left: 4px solid #e91e63 !important; }
        .seed-range-9 { background-color: #f1f8e9 !important; border-left: 4px solid #8bc34a !important; }
        
        /* Ensure these colors are applied with higher specificity */
        tr.seed-range-0 { background-color: #fff3cd !important; border-left: 4px solid #ffc107 !important; }
        tr.seed-range-1 { background-color: #e3f2fd !important; border-left: 4px solid #2196f3 !important; }
        tr.seed-range-2 { background-color: #e8f5e8 !important; border-left: 4px solid #4caf50 !important; }
        tr.seed-range-3 { background-color: #f3e5f5 !important; border-left: 4px solid #9c27b0 !important; }
        tr.seed-range-4 { background-color: #ffebee !important; border-left: 4px solid #f44336 !important; }
        tr.seed-range-5 { background-color: #fff8e1 !important; border-left: 4px solid #ff9800 !important; }
        tr.seed-range-6 { background-color: #f5f5f5 !important; border-left: 4px solid #9e9e9e !important; }
        tr.seed-range-7 { background-color: #e0f2f1 !important; border-left: 4px solid #009688 !important; }
        tr.seed-range-8 { background-color: #fce4ec !important; border-left: 4px solid #e91e63 !important; }
        tr.seed-range-9 { background-color: #f1f8e9 !important; border-left: 4px solid #8bc34a !important; }

        /* Seeding Clash Styles */
        .switch {
          position: relative;
          display: inline-block;
          width: 50px;
          height: 24px;
        }
        .switch input {display:none;}
        .slider {
          position: absolute;
          cursor: pointer;
          top: 0; left: 0; right: 0; bottom: 0;
          background-color: #ccc;
          transition: .4s;
          border-radius: 24px;
        }
        .slider:before {
          position: absolute;
          content: "";
          height: 18px;
          width: 18px;
          left: 3px;
          bottom: 3px;
          background-color: white;
          transition: .4s;
          border-radius: 50%;
        }
        input:checked + .slider {
          background-color: #2196f3;
        }
        input:checked + .slider:before {
          transform: translateX(26px);
        }
        
        /* Enhanced cascaded animation styles for row movement */
        .players-table tr {
          transition: transform 0.3s ease, background-color 0.3s ease, box-shadow 0.3s ease;
        }
        
        .players-table tr.moving {
          z-index: 1000;
          box-shadow: 0 4px 12px rgba(0,0,0,0.3);
          border-radius: 4px;
        }
        
        .players-table tr.moving-up {
          background-color: #fff3cd;
          border: 2px solid #ffc107;
        }
        
        .players-table tr.moving-down {
          background-color: #d4edda;
          border: 2px solid #28a745;
        }
        
        /* Cascaded animation specific styles */
        .players-table tr.cascaded-moving {
          position: relative;
          z-index: 1000;
          box-shadow: 0 6px 16px rgba(0,0,0,0.4);
          border-radius: 6px;
          transition: transform 1s cubic-bezier(0.4,0,0.2,1), 
                      background-color 1s ease, 
                      box-shadow 1s ease, 
                      border 1s ease;
        }
        
        .players-table tr.cascaded-moving.up {
          background-color: #fff3cd;
          border: 2px solid #ffc107;
        }
        
        .players-table tr.cascaded-moving.down {
          background-color: #e8f5e8;
          border: 2px solid #28a745;
        }
        
        /* Animation progress indicators */
        .players-table tr.cascaded-moving.up.animating {
          background-color: #d4edda;
          border-color: #28a745;
        }
        
        .players-table tr.cascaded-moving.down.animating {
          background-color: #fff3cd;
          border-color: #ffc107;
        }

        /* Toggle Switch Styles */
        .switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .switch .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .switch .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        .switch input:checked + .slider {
            background-color: #2196f3;
        }

        .switch input:checked + .slider:before {
            transform: translateX(26px);
        }

        /* Message Box Styles */
        .message {
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 16px;
            font-weight: 500;
            display: none;
        }

        .message.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .message.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
    </style>
</head>
<body>
    {% include 'menu.html' %}
    <div class="container">
        <div class="header">
            <img src="{{ url_for('static', filename='dilliLabsIcon.png') }}" alt="DilliLabs Logo" class="logo">
            <h1>{{ tournament['Tournament Name'] }}</h1>
        </div>
        
        {% if tournament['Tournament Logo Link'] %}
            <div class="tournament-logos-section">
                <div class="tournament-logos">
                    {% set logo_links = tournament['Tournament Logo Link'].split(',') %}
                    {% for logo_link in logo_links %}
                        <img src="{{ url_for('static', filename=logo_link.replace('static/', '')) }}" 
                             alt="Tournament Logo" 
                             class="tournament-logo">
                    {% endfor %}
                </div>
            </div>
        {% endif %}

        <div class="content" data-tournament-id="{{ tournament['Tournament Id'] }}">
            <div class="tab-header">
                <button class="tab-button active" onclick="showTab('info')" id="tab-info">
                    <i class="fas fa-info-circle"></i>Info
                </button>
                <button class="tab-button" onclick="showTab('register')" id="tab-register" {% if not registration_open %}disabled{% endif %}>
                    <i class="fas fa-user-plus"></i>Add Player
                </button>
                <button class="tab-button" onclick="showTab('entries')" id="tab-entries">
                    <i class="fas fa-list"></i>Entries
                </button>
                <button class="tab-button" onclick="showTab('schedule')" id="tab-schedule">
                    <i class="fas fa-calendar"></i>Schedule
                </button>
                <button class="tab-button" onclick="showTab('draws')" id="tab-draws">
                    <i class="fas fa-trophy"></i>Draws
                </button>
                <button class="tab-button" onclick="showTab('manage')" id="tab-manage">
                    <i class="fas fa-cog"></i>Manage
                </button>
            </div>

            <!-- Info Tab -->
            <div id="info" class="tab-content">
                <div id="section-info" class="detail-card">
                    <div class="detail-section">
                        <h2 class="section-title">Tournament Information</h2>
                        <div class="bg-white rounded-lg shadow-md p-6">
                            <div class="detail-grid">
                                <div class="detail-item">
                                    <div class="detail-label">Tournament Name</div>
                                    <div class="detail-value">
                                        {{ tournament['Tournament Name'] }}
                                        {% if tournament_status == 'Upcoming' %}
                                            <span class="status-badge upcoming">Upcoming</span>
                                        {% elif tournament_status == 'In Progress' %}
                                            <span class="status-badge in-progress">In Progress</span>
                                        {% elif tournament_status == 'Completed' %}
                                            <span class="status-badge completed">Completed</span>
                                        {% else %}
                                            <span class="status-badge">Unknown</span>
                                        {% endif %}
                                    </div>
                                </div>
                                <div class="detail-item">
                                    <div class="detail-label">Venue</div>
                                    <div class="detail-value">{{ tournament['Venue'] }}</div>
                                </div>
                                <div class="detail-item">
                                    <div class="detail-label">Tournament Dates</div>
                                    <div class="detail-value">
                                        {% set start_date = tournament['Start Date'].split('-') %}
                                        {% set end_date = tournament['End Date'].split('-') %}
                                        {{ start_date[2] }} {{ ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][start_date[1]|int - 1] }} {{ start_date[0] }} - 
                                        {{ end_date[2] }} {{ ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][end_date[1]|int - 1] }} {{ end_date[0] }}
                                    </div>
                                </div>
                                {% if tournament_status == 'Upcoming' %}
                                <div class="detail-item">
                                    <div class="detail-label">Time Until Start</div>
                                    <div class="detail-value">
                                        <div class="countdown-container flex items-center gap-1">
                                            <div class="countdown-item">
                                                <div class="countdown-value" id="days">00</div>
                                                <div class="countdown-label">Days</div>
                                            </div>
                                            <div class="countdown-separator">:</div>
                                            <div class="countdown-item">
                                                <div class="countdown-value" id="hours">00</div>
                                                <div class="countdown-label">Hours</div>
                                            </div>
                                            <div class="countdown-separator">:</div>
                                            <div class="countdown-item">
                                                <div class="countdown-value" id="minutes">00</div>
                                                <div class="countdown-label">Mins</div>
                                            </div>
                                            <div class="countdown-separator">:</div>
                                            <div class="countdown-item">
                                                <div class="countdown-value" id="seconds">00</div>
                                                <div class="countdown-label">Secs</div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                {% endif %}
                                <div class="detail-item">
                                    <div class="detail-label">Last Registration Date</div>
                                    <div class="detail-value">
                                        {% set reg_date = tournament['Last Registration Date'].split('-') %}
                                        {{ reg_date[2] }} {{ ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'][reg_date[1]|int - 1] }} {{ reg_date[0] }}
                                    </div>
                                </div>
                                <div class="detail-item">
                                    <div class="detail-label">Total Prize</div>
                                    <div class="detail-value">₹{{ tournament['Total Prize'] }}</div>
                                </div>
                                {% if tournament['General Information'] %}
                                <div class="detail-item" style="grid-column: 1 / -1;">
                                    <div class="detail-label">Tournament Description</div>
                                    <div class="detail-value" style="white-space: pre-line;">{{ tournament['General Information'] }}</div>
                                </div>
                                {% endif %}
                            </div>
                        </div>
                    </div>

                    {% if registration_open %}
                    <div class="registration-button-container">
                        <button onclick="showTab('register')" class="submit-button">
                            <i class="fas fa-user-plus"></i> Add Player
                        </button>
                    </div>
                    {% endif %}
                    </div>

                    <div class="detail-section">
                        <h2 class="section-title">Categories</h2>
                        <table class="categories-table">
                            <thead>
                                <tr>
                                    <th>Category</th>
                                    <th>Fee</th>
                                    <th>Prizes</th>
                                    <th>Format</th>
                                </tr>
                            </thead>
                            <tbody>
                                {% for category in categories %}
                                <tr>
                                    <td>{{ category['Category'] }}</td>
                                    <td>₹{{ category['Fee'] }}</td>
                                    <td>
                                        <div class="prize-group">
                                            <div class="prize-item">
                                                <span class="prize-label">First Prize:</span>
                                                <span class="prize-value">₹{{ category['First Prize'] }}</span>
                                            </div>
                                            <div class="prize-item">
                                                <span class="prize-label">Second Prize:</span>
                                                <span class="prize-value">₹{{ category['Second Prize'] }}</span>
                                            </div>
                                            <div class="prize-item">
                                                <span class="prize-label">Third Prize:</span>
                                                <span class="prize-value">₹{{ category['Third Prize'] }}</span>
                                            </div>
                                        </div>
                                    </td>
                                    <td>{{ category['Format'] }}</td>
                                </tr>
                                {% endfor %}
                            </tbody>
                        </table>
                </div>
                    </div>

            <!-- Register Tab -->
            <div id="register" class="tab-content">
                <div id="section-register" class="detail-card">
                    <h2 class="section-title">Add Player</h2>
                    
                    {% if not registration_open %}
                    <div class="registration-closed-message">
                        <i class="fas fa-exclamation-circle"></i>
                        Entries have now closed for this tournament. The last registration date was {{ tournament['Last Registration Date']|datetime }}.
                    </div>
                    {% else %}
                    <!-- Error Message -->
                    {% if request.args.get('error') %}
                    <div class="error-message">
                        {{ request.args.get('error') }}
                    </div>
                    {% endif %}

                    <form class="registration-form" id="registrationForm" method="POST" action="{{ url_for('register_player', tournament_id=tournament['Tournament Id']) }}">
                        <!-- Selected Players List -->
                        <div id="selectedPlayersList" class="selected-players-list" style="margin-bottom: 20px; display: none;">
                            <h3 style="color: #1e3c72; margin-bottom: 15px;">Selected Players</h3>
                            <div id="selectedPlayersContainer"></div>
                            <button type="button" id="addAnotherPlayer" class="submit-button" style="background: #4CAF50; margin-top: 10px;">
                                <i class="fas fa-plus"></i> Add Another Player
                            </button>
                        </div>

                        <!-- Player Search -->
                        <div class="form-group required player-search-container" style="position: relative;">
                            <label for="playerSearch">Search Player</label>
                            <input type="text" id="playerSearch" class="form-control" placeholder="Type player name to search...">
                            <div id="searchResults" class="search-results"></div>
                        </div>

                        <!-- Selected Player Info -->
                        <div id="selectedPlayer" class="selected-player">
                            <div class="form-group">
                                <label>Player Details</label>
                                <div id="playerDetails"></div>
                            </div>
                        </div>

                        <!-- Category Selection -->
                        <div class="form-group required" id="categorySelection" style="display: none;">
                            <label>Select Categories</label>
                            <div id="categoryCheckboxes">
                                {% for category in categories %}
                                <div class="category-checkbox">
                                    <input type="checkbox" id="category_{{ loop.index }}" name="categories" value="{{ category.Category }}" data-fee="{{ category.Fee }}" data-first-prize="{{ category['First Prize'] }}" data-second-prize="{{ category['Second Prize'] }}" data-third-prize="{{ category['Third Prize'] }}" data-format="{{ category.Format }}">
                                    <label for="category_{{ loop.index }}">{{ category.Category }} (₹{{ category.Fee }})</label>
                                </div>
                                {% endfor %}
                            </div>
                            <button type="button" id="addPlayerToSelection" class="submit-button" style="background: #4CAF50; margin-top: 10px; display: none;">
                                <i class="fas fa-plus"></i> Add Player with Selected Categories
                            </button>
                        </div>

                        <!-- Fee Summary -->
                        <div class="fee-summary" id="feeSummary" style="display: none;">
                            <h3>Fee Summary</h3>
                            <div id="feeDetails"></div>
                            <div class="fee-row fee-total">
                                <span>Total Fee:</span>
                                <span id="totalFee">₹0</span>
                            </div>

                            <!-- Payment Details Section -->
                            <div class="payment-details-section" style="margin-top: 24px; padding-top: 24px; border-top: 2px solid #e0e0e0;">
                                <h3 style="color: #1e3c72; margin-bottom: 20px; font-size: 1.2em;">Payment Instructions</h3>
                                
                                {% if tournament['Bank Account'] %}
                                <div class="form-group" style="margin-bottom: 20px;">
                                    <label style="font-weight: 600; color: #1e3c72;">Bank Account Details</label>
                                    <div class="bank-details-box" style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e0e0e0; margin-top: 8px;">
                                        <pre style="margin: 0; font-size: 15px; white-space: pre-wrap; font-family: 'Roboto', sans-serif;">{{ tournament['Bank Account'] }}</pre>
                                    </div>
                                </div>
                                {% endif %}

                                {% if tournament['UPI Link'] %}
                                <div class="form-group" style="margin-bottom: 20px;">
                                    <label style="font-weight: 600; color: #1e3c72;">UPI Payment Link</label>
                                    <div class="upi-link-box" style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e0e0e0; margin-top: 8px;">
                                        <a href="{{ tournament['UPI Link'] }}" target="_blank" style="color: #1e3c72; text-decoration: none; font-size: 15px; word-break: break-all;">
                                            <i class="fas fa-external-link-alt" style="margin-right: 5px;"></i>
                                            {{ tournament['UPI Link'] }}
                                        </a>
                                    </div>
                                </div>
                                {% endif %}

                                {% if tournament['Payment QR'] %}
                                <div class="form-group" style="margin-bottom: 20px;">
                                    <label style="font-weight: 600; color: #1e3c72;">Scan QR Code to Pay</label>
                                    <div class="qr-box" style="background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e0e0e0; margin-top: 8px; display: flex; align-items: center; justify-content: center;">
                                        <img src="{{ url_for('static', filename=tournament['Payment QR'].replace('static/', '')) }}" 
                                             alt="Payment QR Code" 
                                             style="max-width: 200px; max-height: 200px; border-radius: 4px;">
                                    </div>
                                </div>
                                {% endif %}

                                <div class="payment-verification" style="margin-top: 30px; padding-top: 20px; border-top: 1px solid #e0e0e0;">
                                    <h4 style="color: #1e3c72; margin-bottom: 15px;">Payment Verification</h4>
                                    <div class="form-group required">
                                        <label for="payment_id" style="font-weight: 600;">Payment ID / Reference Number</label>
                                        <input type="text" id="payment_id" name="payment_id" class="form-control" 
                                               placeholder="Enter payment transaction/reference ID" required>
                                        <small style="color: #666; margin-top: 5px; display: block;">
                                            Enter the transaction ID or reference number from your payment
                                        </small>
                                    </div>
                                    <div class="form-group required">
                                        <label for="payment_snapshot" style="font-weight: 600;">Payment Screenshot</label>
                                        <input type="file" id="payment_snapshot" name="payment_snapshot" 
                                               class="form-control" accept="image/*" required>
                                        <small style="color: #666; margin-top: 5px; display: block;">
                                            Upload a screenshot of your payment confirmation
                                        </small>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Submit Button -->
                        <button type="submit" class="submit-button" id="submitButton" disabled>
                            Pay Fee and Add Entry
                        </button>
                    </form>
                    {% endif %}
                </div>
            </div>

            <!-- Entries Tab -->
            <div id="entries" class="tab-content">
                <div id="section-entries" class="detail-card">
                    <h2 class="section-title">Tournament Entries</h2>
                    
                    <!-- Success Message -->
                    {% if request.args.get('message') %}
                    <div class="success-message">
                        {{ request.args.get('message') }}
                    </div>
                    {% endif %}

                    <div class="entries-container">
                        <!-- Girls Categories -->
                        <div class="category-section">
                            <h3>Girls Categories</h3>
                            <div class="category-grid">
                                {% for category, entries in girls_entries.items() %}
                                <div class="category-box">
                                    <h4>{{ category }} ({{ entries|length }})</h4>
                                    <ul class="player-list">
                                            {% for entry in entries %}
                                        <li>{{ entry.Name }}</li>
                                            {% endfor %}
                                    </ul>
                                </div>
                                {% endfor %}
                            </div>
                        </div>

                        <!-- Boys Categories -->
                        <div class="category-section">
                            <h3>Boys Categories</h3>
                            <div class="category-grid">
                                {% for category, entries in boys_entries.items() %}
                                <div class="category-box">
                                    <h4>{{ category }} ({{ entries|length }})</h4>
                                    <ul class="player-list">
                                            {% for entry in entries %}
                                        <li>{{ entry.Name }}</li>
                                            {% endfor %}
                                    </ul>
                                </div>
                                {% endfor %}
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Schedule Tab -->
            <div id="schedule" class="tab-content">
                <div id="section-schedule" class="detail-card">
                    <h2 class="section-title">Tournament Schedule</h2>
                    <div class="schedule-container">
                        <div class="schedule-filters">
                            <select id="categoryFilter" class="filter-select">
                                <option value="">All Categories</option>
                                {% for category in categories %}
                                <option value="{{ category['Category'] }}">{{ category['Category'] }}</option>
                                {% endfor %}
                            </select>
                            <select id="dateFilter" class="filter-select">
                                <option value="">All Dates</option>
                                <!-- Dates will be populated dynamically -->
                            </select>
                        </div>
                        <div class="schedule-timeline">
                            <!-- Schedule will be loaded dynamically -->
                            <div class="loading">Loading schedule...</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Draws Tab -->
            <div id="draws" class="tab-content">
                <div id="section-draws" class="detail-card">
                    <h2 class="section-title">Tournament Draws</h2>
                    <div class="draws-container">
                        <div class="draws-filters">
                            <select id="drawCategoryFilter" class="filter-select">
                                <option value="">Select Category</option>
                                {% for category in categories %}
                                <option value="{{ category['Category'] }}">{{ category['Category'] }}</option>
                                {% endfor %}
                            </select>
                        </div>
                        <div class="draws-content">
                            <!-- Draws will be loaded dynamically -->
                            <div class="loading">Select a category to view draws</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Manage Tab -->
            <div id="manage" class="tab-content">
                <div id="section-manage" class="detail-card">
                    <h2 class="section-title">Manage Tournament</h2>
                    
                    <!-- Horizontal Steps -->
                    <div class="steps-container" style="display: flex; gap: 5px; margin: 20px 0; justify-content: space-between;">
                        <!-- Step 1: Update Seeding -->
                        <div class="step-item" style="flex: 1; padding: 10px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef; cursor: pointer; text-align: center;" onclick="showStepContent(1)">
                            <div class="step-header" style="display: flex; align-items: center; justify-content: center; gap: 5px;">
                                <div class="step-number" style="width: 24px; height: 24px; background: #1e3c72; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.9em;">1</div>
                                <h3 style="margin: 0; color: #1e3c72; font-size: 0.9em;">Update Seeding</h3>
                            </div>
                        </div>

                        <!-- Step 2: Resolve Seeding Clash -->
                        <div class="step-item" style="flex: 1; padding: 10px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef; cursor: pointer; text-align: center;" onclick="showStepContent(2)">
                            <div class="step-header" style="display: flex; align-items: center; justify-content: center; gap: 5px;">
                                <div class="step-number" style="width: 24px; height: 24px; background: #1e3c72; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.9em;">2</div>
                                <h3 style="margin: 0; color: #1e3c72; font-size: 0.9em;">Resolve Seeding Clash</h3>
                            </div>
                        </div>

                        <!-- Step 3: Create Draws -->
                        <div class="step-item" style="flex: 1; padding: 10px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef; cursor: pointer; text-align: center;" onclick="showStepContent(3)">
                            <div class="step-header" style="display: flex; align-items: center; justify-content: center; gap: 5px;">
                                <div class="step-number" style="width: 24px; height: 24px; background: #1e3c72; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.9em;">3</div>
                                <h3 style="margin: 0; color: #1e3c72; font-size: 0.9em;">Create Draws</h3>
                            </div>
                        </div>

                        <!-- Step 4: Create Brackets -->
                        <div class="step-item" style="flex: 1; padding: 10px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef; cursor: pointer; text-align: center;" onclick="showStepContent(4)">
                            <div class="step-header" style="display: flex; align-items: center; justify-content: center; gap: 5px;">
                                <div class="step-number" style="width: 24px; height: 24px; background: #1e3c72; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 0.9em;">4</div>
                                <h3 style="margin: 0; color: #1e3c72; font-size: 0.9em;">Create Brackets</h3>
                            </div>
                        </div>
                    </div>

                    <!-- Step Content Areas -->
                    <div id="stepContent" style="margin-top: 20px;">
                        <!-- Step 1 Content -->
                        <div id="step1Content" class="step-content-area" style="display: none;">
                            <h3 style="color: #1e3c72; margin-bottom: 20px;">Update Seeding</h3>
                            <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 20px;">
                                <div class="form-group" style="margin: 0;">
                                    <select id="seedingCategorySelect" class="form-control" style="max-width: 300px;">
                                        <option value="">Select a category</option>
                                        {% for category in categories %}
                                        <option value="{{ category['Category'] }}">{{ category['Category'] }}</option>
                                        {% endfor %}
                                    </select>
                                </div>
                                
                                <!-- Update Seeding Buttons -->
                                <div style="display: flex; align-items: center; gap: 16px;">
                                    <button type="submit" id="saveButton" class="form-control" style="background-color: #1e3c72; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 500; height: 38px; min-width: 120px; display: none;" onclick="saveSeeding(event)">
                                        <i class="fas fa-save"></i> Save
                                    </button>
                                    <button type="button" id="resetSeedsButton" class="form-control" style="background-color: #dc3545; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 500; height: 38px; min-width: 120px; display: none;">
                                        <i class="fas fa-sync"></i> Reset
                                    </button>
                                </div>
                            </div>

                            <div id="playersContainer" class="players-container" style="margin-top: 20px; display: none;">
                                <form id="seedingForm" onsubmit="saveSeeding(event)">
                                    <!-- Message Box for Update Seeding -->
                                    <div id="messageBox" class="message" style="margin-bottom: 10px; padding: 10px; border-radius: 4px; display: none;"></div>
                                    <table class="players-table" style="width: 100%; border-collapse: collapse;">
                                        <thead>
                                            <tr>
                                                <th style="background: #f5f5f5; padding: 12px; text-align: left; font-weight: 500; border-bottom: 2px solid #ddd;">Player Name</th>
                                                <th style="width: 120px; background: #f5f5f5; padding: 12px; text-align: left; font-weight: 500; border-bottom: 2px solid #ddd;">Last Rank</th>
                                                <th style="width: 120px; background: #f5f5f5; padding: 12px; text-align: left; font-weight: 500; border-bottom: 2px solid #ddd;">Seed</th>
                                            </tr>
                                        </thead>
                                        <tbody id="playersTableBody">
                                            <!-- Players will be loaded here -->
                                        </tbody>
                                    </table>
                                </form>
                            </div>
                        </div>

                        <!-- Step 2 Content -->
                        <div id="step2Content" class="step-content-area" style="display: none;">
                            <h3 style="color: #1e3c72; margin-bottom: 20px;">Resolve Seeding Clash</h3>
                            <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 20px;">
                                <div class="form-group" style="margin: 0;">
                                    <select id="clashCategorySelect" class="form-control" style="max-width: 300px;">
                                        <option value="">Select a category</option>
                                        {% for category in categories %}
                                        <option value="{{ category['Category'] }}">{{ category['Category'] }}</option>
                                        {% endfor %}
                                    </select>
                                </div>
                                
                                <!-- Clash Resolution Mode Toggle -->
                                <div id="clashModeToggle" style="display: flex; align-items: center; gap: 16px;">
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <span id="manualLabel" style="font-weight: 500; color: #9c27b0;">Manual</span>
                                        <label class="switch">
                                            <input type="checkbox" id="clashModeSwitch" onchange="toggleClashMode()">
                                            <span class="slider round"></span>
                                        </label>
                                        <span id="autoLabel" style="font-weight: 500; color: #2196f3;">Automatic</span>
                                    </div>
                                    <button id="saveSeedsBtn" class="form-control" style="background-color: #1e3c72; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-size: 14px; font-weight: 500; height: 38px; min-width: 120px;" onclick="saveAllSeedChanges()">
                                        <i class="fas fa-save"></i> Save
                                    </button>
                                </div>
                            </div>

                            <div id="clashContainer" class="players-container" style="margin-top: 20px; display: none;">
                                <!-- Message Box for Clash Resolution -->
                                <div id="clashMessageBox" class="message" style="margin-bottom: 10px; padding: 10px; border-radius: 4px; display: none;"></div>
                                <table class="players-table" style="width: 100%; border-collapse: collapse;">
                                    <thead>
                                        <tr>
                                            <th style="width: 60px; background: #f5f5f5; padding: 12px; text-align: center; font-weight: 500; border-bottom: 2px solid #ddd;">S.No.</th>
                                            <th style="background: #f5f5f5; padding: 12px; text-align: left; font-weight: 500; border-bottom: 2px solid #ddd;">Player Name</th>
                                            <th style="width: 120px; background: #f5f5f5; padding: 12px; text-align: left; font-weight: 500; border-bottom: 2px solid #ddd;">Seed</th>
                                        </tr>
                                    </thead>
                                    <tbody id="clashTableBody">
                                        <!-- Players will be loaded here -->
                                    </tbody>
                                </table>

                                <style>
                                .switch {
                                  position: relative;
                                  display: inline-block;
                                  width: 50px;
                                  height: 24px;
                                }
                                .switch input {display:none;}
                                .slider {
                                  position: absolute;
                                  cursor: pointer;
                                  top: 0; left: 0; right: 0; bottom: 0;
                                  background-color: #ccc;
                                  transition: .4s;
                                  border-radius: 24px;
                                }
                                .slider:before {
                                  position: absolute;
                                  content: "";
                                  height: 18px;
                                  width: 18px;
                                  left: 3px;
                                  bottom: 3px;
                                  background-color: white;
                                  transition: .4s;
                                  border-radius: 50%;
                                }
                                input:checked + .slider {
                                  background-color: #2196f3;
                                }
                                input:checked + .slider:before {
                                  transform: translateX(26px);
                                }
                                </style>

                                <!-- Clash Summary Container -->
                                <div id="clashSummary" class="clash-summary" style="display: none;">
                                    <h4>Seeding Clashes Detected</h4>
                                    <div id="clashItems">
                                        <!-- Clash items will be generated here -->
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Step 3 Content -->
                        <div id="step3Content" class="step-content-area" style="display: none;">
                            <h3 style="color: #1e3c72; margin-bottom: 20px;">Create Draws</h3>
                            
                            <!-- Controls Section -->
                            <div style="display: flex; align-items: center; gap: 20px; margin-bottom: 20px; flex-wrap: wrap;">
                                <!-- Category Selection -->
                                <div class="form-group" style="margin: 0;">
                                    <select id="drawCategorySelect" class="form-control" style="max-width: 300px;">
                                        <option value="">Select a category</option>
                                        {% for category in categories %}
                                        <option value="{{ category['Category'] }}">{{ category['Category'] }}</option>
                                        {% endfor %}
                                    </select>
                                </div>
                                
                                <!-- Group Selection and Save Button -->
                                <div style="display: flex; align-items: center; gap: 15px;">
                                    <div class="form-group" style="margin: 0;">
                                        <!-- <label for="drawGroupSelect" style="display: block; margin-bottom: 5px; color: #1e3c72; font-weight: 500; font-size: 14px;">Group</label> -->
                                        <select id="drawGroupSelect" class="form-control" style="max-width: 200px;">
                                            <option value="">Select Group</option>
                                            <option value="None">None</option>
                                            <option value="State">State</option>
                                            <option value="District">District</option>
                                            <option value="School/Institution">School/Institution</option>
                                            <option value="Academy">Academy</option>
                                        </select>
                                    </div>
                                    
                                    <!-- Action Buttons -->
                                    <div class="form-group" style="margin: 0; display: flex; gap: 10px;">
                                        <button id="autoAssignButton" class="btn btn-success" style="background-color: #28a745; border: none; padding: 8px 16px; font-size: 14px; font-weight: 500; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); height: 38px;" onclick="assignSeedsAutomatically()">
                                            <i class="fas fa-magic"></i> Auto Assign
                                        </button>
                                        <button id="clearSeedsButton" class="btn btn-warning" style="background-color: #ffc107; border: none; padding: 8px 16px; font-size: 14px; font-weight: 500; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); height: 38px;" onclick="clearAllSeedSelections()">
                                            <i class="fas fa-eraser"></i> Clear Seeds
                                        </button>
                                        <button id="saveDrawButton" class="btn btn-primary" style="background-color: #1e3c72; border: none; padding: 8px 16px; font-size: 14px; font-weight: 500; border-radius: 6px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); height: 38px;" onclick="saveDrawChanges()">
                                            <i class="fas fa-save"></i> Save
                                        </button>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Message Box -->
                            <div id="drawMessageBox" class="message" style="display: none; margin-bottom: 20px;"></div>
                            
                            <!-- Players Table Container -->
                            <div id="drawPlayersContainer" style="display: none;">
                                <table class="table table-striped" style="width: 100%; border-collapse: collapse; background: white; box-shadow: 0 2px 4px rgba(0,0,0,0.1); border-radius: 8px; overflow: hidden;">
                                    <thead>
                                        <tr>
                                            <th style="padding: 16px; text-align: left; background: #1e3c72; color: white; font-weight: 500; font-size: 0.95em; border-bottom: 2px solid #2a5298;">S.No.</th>
                                            <th style="padding: 16px; text-align: left; background: #1e3c72; color: white; font-weight: 500; font-size: 0.95em; border-bottom: 2px solid #2a5298;">Name</th>
                                            <th style="padding: 16px; text-align: left; background: #1e3c72; color: white; font-weight: 500; font-size: 0.95em; border-bottom: 2px solid #2a5298;">Group</th>
                                            <th style="padding: 16px; text-align: left; background: #1e3c72; color: white; font-weight: 500; font-size: 0.95em; border-bottom: 2px solid #2a5298; cursor: pointer;" onclick="sortTableBySeed()" title="Click to sort by seed">Seed <i class="fas fa-sort" style="margin-left: 5px;"></i></th>
                                        </tr>
                                    </thead>
                                    <tbody id="drawPlayersTableBody">
                                        <!-- Players will be loaded here -->
                                    </tbody>
                                </table>
                                
                                <!-- Create Draw Button -->
                                <div style="margin-top: 20px; text-align: center;">
                                    <button id="create-draw-btn" class="btn btn-primary" style="background-color: #1e3c72; border: none; padding: 12px 24px; font-size: 16px; font-weight: 500; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.15); display: none;" onclick="startShuffling()">
                                        <i class="fas fa-play"></i> Create Draw
                                    </button>
                                    <button id="stop-shuffle-btn" class="btn btn-warning" style="background-color: #ff9800; border: none; padding: 12px 24px; font-size: 16px; font-weight: 500; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.15); display: none;" onclick="stopShuffling()">
                                        <i class="fas fa-stop"></i> Stop Shuffle
                                    </button>
                                    <button id="save-draw-btn" class="btn btn-success" style="background-color: #28a745; border: none; padding: 12px 24px; font-size: 16px; font-weight: 500; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.15); display: none;" onclick="saveDraw()">
                                        <i class="fas fa-save"></i> Save Draw
                                    </button>
                                </div>
                                
                                <!-- Status Message -->
                                <div id="status-message" class="message" style="display: none; margin-top: 20px;"></div>
                                
                                <!-- Shuffle Counter -->
                                <div id="shuffleCounter" style="display: none; text-align: center; margin-top: 20px; font-size: 18px; color: #1e3c72; font-weight: bold;">
                                    Shuffling... <span id="shuffleCount">0</span>
                                </div>
                            </div>
                        </div>

                        <!-- Step 4 Content -->
                        <div id="step4Content" class="step-content-area" style="display: none;">
                            <h3 style="color: #1e3c72; margin-bottom: 20px;">Create Brackets</h3>
                            <div class="bracket-controls">
                                <select id="categorySelect" class="form-control">
                                    <option value="">Select Category</option>
                                    {% for category in categories %}
                                    <option value="{{ category['Category'] }}">{{ category['Category'] }}</option>
                                    {% endfor %}
                                </select>
                                <button id="generateBracket" class="btn btn-primary" disabled>Generate Bracket</button>
                            </div>

                            <div class="bracket-container">
                                <div id="bracket" class="bracket">
                                    <!-- Bracket will be generated here -->
                                </div>
                            </div>
                            
                            <!-- Match Results Modal -->
                            <div id="matchResultsModal" class="modal">
                                <div class="modal-content">
                                    <span class="close" id="modalClose">&times;</span>
                                    <h3 id="modalTitle">Update Match Results</h3>
                                    <div id="modalContent">
                                        <!-- Results table will be generated here -->
                                    </div>
                                    <div class="modal-buttons">
                                        <button class="btn-cancel" id="modalCancel">Cancel</button>
                                        <button class="btn-save" id="modalSave">Save Results</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    {% include 'footer.html' %}

    <script>
        // Global variable to track last selected category across Manage tab steps
        let lastSelectedCategory = null;

        function showTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.style.display = 'none';
            });
            
            // Remove active class from all tab buttons
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName).style.display = 'block';
            
            // Add active class to selected tab button
            document.getElementById('tab-' + tabName).classList.add('active');
            
            // Update URL hash without scrolling
            history.pushState(null, null, '#' + tabName);
        }

        // Handle initial tab based on URL hash or parameters
        document.addEventListener('DOMContentLoaded', function() {
            const urlParams = new URLSearchParams(window.location.search);
            const tabParam = urlParams.get('tab');
            
            if (tabParam) {
                showTab(tabParam);
            } else {
                const hash = window.location.hash.substring(1);
                if (hash) {
                    showTab(hash);
                } else {
                    showTab('info'); // Default to info tab
                }
            }
        });

        // Handle browser back/forward buttons
        window.addEventListener('popstate', function() {
            const hash = window.location.hash.substring(1);
            if (hash) {
                showTab(hash);
            } else {
                showTab('info');
            }
        });

        // Function to load entries for a category
        function loadEntries(category) {
            // Implementation will be added
        }

        // Function to load schedule
        function loadSchedule() {
            // Implementation will be added
        }

        // Function to load draws
        function loadDraws(category) {
            // Implementation will be added
        }

        // Event listeners for filters
        document.getElementById('categoryFilter')?.addEventListener('change', function() {
            loadSchedule();
        });

        document.getElementById('dateFilter')?.addEventListener('change', function() {
            loadSchedule();
        });

        document.getElementById('drawCategoryFilter')?.addEventListener('change', function() {
            loadDraws(this.value);
        });
    </script>

    <script>
        $(document).ready(function() {
            let selectedPlayers = [];
            let currentPlayer = null;
            let searchTimeout;
            let editingIndex = -1;

            // Player search functionality
            $('#playerSearch').on('keyup', function() {
                const searchTerm = $(this).val().trim();
                const searchResults = $('#searchResults');
                
                if (searchTerm.length < 2) {
                    searchResults.hide();
                    return;
                }

                // Clear previous timeout
                if (searchTimeout) {
                    clearTimeout(searchTimeout);
                }

                // Set new timeout
                searchTimeout = setTimeout(function() {
                    $.ajax({
                        url: '/get-players',
                        method: 'GET',
                        data: { name: searchTerm },
                        success: function(players) {
                            searchResults.empty();
                            
                            if (players.length === 0) {
                                searchResults.append('<div class="search-result-item">No players found</div>');
                            } else {
                                players.forEach(function(player) {
                                    const item = $('<div>')
                                        .addClass('search-result-item')
                                        .html(`<div>${player.Name} - DOB: ${player['Date of Birth']} - State: ${player.State}</div>`)
                                        .data('player', player)
                                        .on('click', function() {
                                            selectPlayer($(this).data('player'));
                                        });
                                    searchResults.append(item);
                                });
                            }
                            
                            searchResults.show();
                        },
                        error: function(error) {
                            console.error('Error searching players:', error);
                            searchResults.hide();
                        }
                    });
                }, 300); // 300ms delay
            });

            // Function to format date
            function formatDate(dob) {
                if (!dob) return '';
                const parts = dob.split('-');
                if (parts.length === 3) {
                    const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                    const day = parts[2].padStart(2, '0');
                    const month = months[parseInt(parts[1]) - 1];
                    const year = parts[0];
                    return `${day}/${parts[1].padStart(2, '0')}/${year}`;
                }
                return dob;
            }

            // Handle category selection
            $('#categoryCheckboxes input[type="checkbox"]').on('change', function() {
                if (currentPlayer) {
                    const selectedCategories = $('#categoryCheckboxes input[type="checkbox"]:checked');
                    
                    // Show/hide the Add Player button based on category selection
                    if (selectedCategories.length > 0) {
                        $('#addPlayerToSelection').show();
                    } else {
                        $('#addPlayerToSelection').hide();
                    }
                }
            });

            // Add Player to Selection button click handler
            $('#addPlayerToSelection').on('click', function() {
                if (!currentPlayer) {
                    alert('Please select a player first');
                    return;
                }

                const selectedCategories = $('#categoryCheckboxes input[type="checkbox"]:checked');
                if (selectedCategories.length === 0) {
                    alert('Please select at least one category');
                    return;
                }

                // Check for duplicate player
                if (editingIndex === -1) {
                    const isDuplicate = selectedPlayers.some(data => data.player['Player ID'] === currentPlayer['Player ID']);
                    if (isDuplicate) {
                        alert('This player has already been added. Please select a different player.');
                        return;
                    }
                }

                const playerData = {
                    player: currentPlayer,
                    categories: selectedCategories.map(function() {
                        return {
                            name: $(this).val(),
                            fee: $(this).data('fee')
                        };
                    }).get()
                };

                if (editingIndex === -1) {
                    selectedPlayers.push(playerData);
                } else {
                    selectedPlayers[editingIndex] = playerData;
                    editingIndex = -1;
                }

                updateSelectedPlayersList();
                updateFeeSummary();
                clearPlayerSelection();
            });

            // Add Another Player button click handler
            $('#addAnotherPlayer').on('click', function() {
                resetPlayerSelection();
                $('#playerSearch').focus();
            });

            function clearPlayerSelection() {
                currentPlayer = null;
                editingIndex = -1;
                $('#playerSearch').val('');
                $('#searchResults').hide();
                $('#selectedPlayer').hide();
                $('#categorySelection').hide();
                $('#categoryCheckboxes input[type="checkbox"]').prop('checked', false);
                $('#addPlayerToSelection').hide();
                $('.player-search-container').hide(); // Hide the entire search container
                updateFeeSummary();
                updateSubmitButton();
            }

            function updateSelectedPlayersList() {
                const container = $('#selectedPlayersContainer');
                container.empty();

                selectedPlayers.forEach((data, index) => {
                    const player = data.player;
                    const categories = data.categories;
                    
                    const playerDiv = $('<div>')
                        .addClass('selected-player-item')
                        .css({
                            'background': '#f8f9fa',
                            'padding': '15px',
                            'margin-bottom': '10px',
                            'border-radius': '8px',
                            'border': '1px solid #e9ecef'
                        });

                    const playerInfo = $('<div>')
                        .addClass('player-info')
                        .html(`
                            <strong>${player.Name}</strong>
                            <span style="float: right;">
                                <button type="button" class="edit-player" data-index="${index}" style="background: none; border: none; color: #1e3c72; cursor: pointer; margin-right: 10px;">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button type="button" class="remove-player" data-index="${index}" style="background: none; border: none; color: #dc3545; cursor: pointer;">
                                    <i class="fas fa-times"></i>
                                </button>
                            </span>
                            <br>
                            <small>DOB: ${player['Date of Birth']} - State: ${player.State}</small>
                        `);

                    const categoriesList = $('<div>')
                        .addClass('categories-list')
                        .css('margin-top', '10px');

                    categories.forEach(category => {
                        categoriesList.append(`
                            <div style="background: #e9ecef; padding: 5px 10px; border-radius: 4px; display: inline-block; margin: 2px;">
                                ${category.name} (₹${category.fee})
                            </div>
                        `);
                    });

                    playerDiv.append(playerInfo).append(categoriesList);
                    container.append(playerDiv);
                });

                // Show/hide the selected players list
                $('#selectedPlayersList').toggle(selectedPlayers.length > 0);

                // Add remove player handler
                $('.remove-player').on('click', function() {
                    const index = $(this).data('index');
                    selectedPlayers.splice(index, 1);
                    updateSelectedPlayersList();
                    updateFeeSummary();
                });

                // Add edit player handler
                $('.edit-player').on('click', function() {
                    const index = $(this).data('index');
                    const playerData = selectedPlayers[index];
                    
                    // Set current player and categories
                    currentPlayer = playerData.player;
                    editingIndex = index;
                    
                    // Update UI
                    $('#playerSearch').val(playerData.player.Name);
                    $('#selectedPlayer').show();
                    $('#categorySelection').show();
                    
                    // Show player details
                    const details = $('#playerDetails');
                    details.html(`
                        <p><strong>Name:</strong> ${playerData.player.Name}</p>
                        <p><strong>Date of Birth:</strong> ${formatDate(playerData.player['Date of Birth'])}</p>
                        <p><strong>Gender:</strong> ${playerData.player.Gender}</p>
                    `);
                    
                    // Check the previously selected categories
                    $('#categoryCheckboxes input[type="checkbox"]').each(function() {
                        const categoryName = $(this).val();
                        const wasSelected = playerData.categories.some(cat => cat.name === categoryName);
                        $(this).prop('checked', wasSelected);
                    });
                    
                    // Update button text
                    $('#addPlayerToSelection').text('Update Player Selection');
                    
                    // Scroll to category selection
                    $('#categorySelection')[0].scrollIntoView({ behavior: 'smooth' });
                });
            }

            function resetPlayerSelection() {
                clearPlayerSelection();
                // Show the player search section
                $('.player-search-container').show();
            }

            // Function to select a player
            function selectPlayer(player) {
                currentPlayer = player;
                $('#playerSearch').val(player.Name);
                $('#searchResults').hide();
                
                // Show player details
                const details = $('#playerDetails');
                details.html(`
                    <p><strong>Name:</strong> ${player.Name}</p>
                    <p><strong>Date of Birth:</strong> ${formatDate(player['Date of Birth'])}</p>
                    <p><strong>Gender:</strong> ${player.Gender}</p>
                `);
                $('#selectedPlayer').show();
                
                // Show category selection
                $('#categorySelection').show();
                
                // Hide the Add Player button initially
                $('#addPlayerToSelection').hide();
                
                // Filter categories based on player's age and gender
                filterCategories(player);
            }

            // Function to filter categories based on player's age and gender
            function filterCategories(player) {
                const dob = new Date(player['Date of Birth']);
                const currentYear = new Date().getFullYear();
                const referenceDate = new Date(currentYear, 11, 31); // December 31st of current year
                
                // Calculate age as of December 31st
                let age = referenceDate.getFullYear() - dob.getFullYear();
                const monthDiff = referenceDate.getMonth() - dob.getMonth();
                if (monthDiff < 0 || (monthDiff === 0 && referenceDate.getDate() < dob.getDate())) {
                    age--;
                }
                
                const gender = player.Gender;

                // Hide all category checkboxes first
                $('.category-checkbox').hide();

                // Show only eligible categories
                $('#categoryCheckboxes input[type="checkbox"]').each(function() {
                    const checkbox = $(this);
                    const categoryName = checkbox.val().toLowerCase();
                    
                    // Determine age eligibility based on category name
                    let minAge = 0;
                    let maxAge = 99;
                    let categoryGender = 'Any';

                    if (categoryName.includes('u9')) {
                        maxAge = 8;
                    } else if (categoryName.includes('u11')) {
                        maxAge = 10;
                    } else if (categoryName.includes('u13')) {
                        maxAge = 12;
                    } else if (categoryName.includes('u15')) {
                        maxAge = 14;
                    } else if (categoryName.includes('u17')) {
                        maxAge = 16;
                    } else if (categoryName.includes('u19')) {
                        maxAge = 18;
                    } else if (categoryName.includes('veterans')) {
                        minAge = 39;
                    }

                    // Determine gender based on category name
                    if (categoryName.includes('girls') || categoryName.includes('women')) {
                        categoryGender = 'Female';
                    } else if (categoryName.includes('boys') || categoryName.includes('men')) {
                        categoryGender = 'Male';
                    }

                    // Show category if player meets age and gender requirements
                    if (age >= minAge && age <= maxAge && 
                        (categoryGender === 'Any' || categoryGender === gender)) {
                        checkbox.closest('.category-checkbox').show();
                    }
                });

                // Clear any previously selected categories
                $('#categoryCheckboxes input[type="checkbox"]').prop('checked', false);
                updateFeeSummary();

                // Show message if no eligible categories
                const eligibleCount = $('.category-checkbox:visible').length;
                if (eligibleCount === 0) {
                    $('#categoryCheckboxes').after(
                        '<div class="error-message">No eligible categories found for this player</div>'
                    );
                } else {
                    $('.error-message').remove();
                }
            }

            // Update fee summary
            function updateFeeSummary() {
                let totalFee = 0;
                const feeDetails = $('#feeDetails');
                feeDetails.empty();

                // Show fee summary if there are selected players
                if (selectedPlayers.length > 0) {
                    $('#feeSummary').show();
                    $('.payment-details-section').show();
                } else {
                    $('#feeSummary').hide();
                    $('.payment-details-section').hide();
                }

                // Calculate fees for all selected players and their categories
                selectedPlayers.forEach(data => {
                    const player = data.player;
                    const categories = data.categories;
                    
                    const playerFee = categories.reduce((sum, cat) => sum + parseFloat(cat.fee), 0);
                    totalFee += playerFee;

                    // Add player's fee details
                    feeDetails.append(`
                        <div class="fee-row" style="margin-bottom: 15px;">
                            <div style="font-weight: 500; color: #1e3c72;">${player.Name}</div>
                            <div style="margin-left: 20px;">
                                ${categories.map(cat => `
                                    <div style="color: #666; margin: 5px 0;">
                                        ${cat.name} - ₹${cat.fee}
                                    </div>
                                `).join('')}
                                <div style="font-weight: 500; color: #1e3c72; margin-top: 5px;">
                                    Subtotal: ₹${playerFee}
                                </div>
                            </div>
                        </div>
                    `);
                });

                // Add total fee
                feeDetails.append(`
                    <div class="fee-row fee-total" style="margin-top: 20px; padding-top: 15px; border-top: 2px solid #e0e0e0;">
                        <span style="font-weight: 600; color: #1e3c72;">Total Fee:</span>
                        <span style="font-weight: 600; color: #1e3c72;">₹${totalFee}</span>
                    </div>
                `);

                $('#totalFee').text(`₹${totalFee}`);
                updateSubmitButton();
            }

            // Update submit button state
            function updateSubmitButton() {
                const hasPlayers = selectedPlayers.length > 0;
                const hasPaymentDetails = $('#payment_id').val() && $('#payment_snapshot').val();
                
                // Enable/disable submit button
                $('#submitButton').prop('disabled', !(hasPlayers && hasPaymentDetails));
            }

            // Add payment validation handlers
            $('#payment_id, #payment_snapshot').on('change input', function() {
                updateSubmitButton();
            });

            // Modify the form submission
            $('#registrationForm').on('submit', function(e) {
                e.preventDefault();
                
                if (selectedPlayers.length === 0) {
                    alert('Please add at least one player');
                    return;
                }

                // Validate payment details
                const paymentId = $('#payment_id').val();
                const paymentSnapshot = $('#payment_snapshot')[0].files[0];

                if (!paymentId) {
                    alert('Please enter the payment ID/reference number');
                    return;
                }

                if (!paymentSnapshot) {
                    alert('Please upload the payment screenshot');
                    return;
                }

                // Show confirmation dialog
                const totalFee = selectedPlayers.reduce((sum, data) => 
                    sum + data.categories.reduce((catSum, cat) => catSum + parseFloat(cat.fee), 0), 0);

                if (!confirm(`Are you sure you want to register ${selectedPlayers.length} player(s) with a total fee of ₹${totalFee}?`)) {
                    return;
                }

                // Function to submit a single player registration
                function submitPlayerRegistration(playerData, index) {
                    return new Promise((resolve, reject) => {
                        const formData = new FormData();
                        
                        // Add tournament ID
                        formData.append('tournament_id', '{{ tournament["Tournament Id"] }}');
                        
                        // Add player ID
                        formData.append('player_id', playerData.player['Player ID']);
                        
                        // Add categories for this player
                        playerData.categories.forEach((category) => {
                            formData.append('categories', category.name);
                        });

                        // Add payment details
                        formData.append('payment_id', paymentId);
                        formData.append('payment_snapshot', paymentSnapshot);

                        // Log the form data
                        console.log(`Form data for player ${index + 1}:`);
                        for (let pair of formData.entries()) {
                            console.log(pair[0] + ': ' + pair[1]);
                        }

                        // Submit the form
                        $.ajax({
                            url: $('#registrationForm').attr('action'),
                            method: 'POST',
                            data: formData,
                            processData: false,
                            contentType: false,
                            success: function(response) {
                                console.log(`Success response for player ${index + 1}:`, response);
                                resolve(response);
                            },
                            error: function(error) {
                                console.error(`Error details for player ${index + 1}:`, error);
                                console.error('Response:', error.responseText);
                                console.error('Status:', error.status);
                                console.error('Status Text:', error.statusText);
                                
                                // Log the form data that was sent
                                console.log(`Form data that was sent for player ${index + 1}:`);
                                for (let pair of formData.entries()) {
                                    console.log(pair[0] + ': ' + pair[1]);
                                }

                                // Try to parse error response if it's JSON
                                let errorMessage = 'Please try again';
                                try {
                                    const errorResponse = JSON.parse(error.responseText);
                                    errorMessage = errorResponse.error || errorResponse.message || errorMessage;
                                } catch (e) {
                                    errorMessage = error.responseText || errorMessage;
                                }
                                
                                reject(new Error(`Error registering player ${index + 1}: ${errorMessage}`));
                            }
                        });
                    });
                }

                // Submit all players sequentially
                async function submitAllPlayers() {
                    try {
                        for (let i = 0; i < selectedPlayers.length; i++) {
                            await submitPlayerRegistration(selectedPlayers[i], i);
                        }
                        
                        // All registrations successful
                        alert('All registrations successful!');
                        // Reset the form
                        selectedPlayers = [];
                        updateSelectedPlayersList();
                        updateFeeSummary();
                        resetPlayerSelection();
                        // Clear payment fields
                        $('#payment_id').val('');
                        $('#payment_snapshot').val('');
                        // Reload the page after a short delay
                        setTimeout(() => window.location.reload(), 1000);
                    } catch (error) {
                        alert(error.message);
                    }
                }

                // Start the submission process
                submitAllPlayers();
            });
        });
    </script>

    <script>
        // Countdown Timer Function
        function updateCountdown() {
            const startDate = new Date("{{ tournament['Start Date'] }}").getTime();
            const now = new Date().getTime();
            const distance = startDate - now;

            if (distance < 0) {
                document.getElementById("days").innerHTML = "00";
                document.getElementById("hours").innerHTML = "00";
                document.getElementById("minutes").innerHTML = "00";
                document.getElementById("seconds").innerHTML = "00";
                return;
            }

            const days = Math.floor(distance / (1000 * 60 * 60 * 24));
            const hours = Math.floor((distance % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
            const minutes = Math.floor((distance % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((distance % (1000 * 60)) / 1000);

            document.getElementById("days").innerHTML = days.toString().padStart(2, '0');
            document.getElementById("hours").innerHTML = hours.toString().padStart(2, '0');
            document.getElementById("minutes").innerHTML = minutes.toString().padStart(2, '0');
            document.getElementById("seconds").innerHTML = seconds.toString().padStart(2, '0');
        }

        // Update countdown every second
        setInterval(updateCountdown, 1000);
        updateCountdown(); // Initial call
    </script>

    <script>
    // Global variables
    let currentPlayers = [];
    let isShuffling = false;
    let shuffleInterval;
    let shuffleCount = 0;
    let seedRanges = null; // Store seeding ranges globally
    const tournamentId = "{{ tournament['Tournament Id'] }}"; // Add tournament ID

    // Table styles
    const cellStyle = `
        padding: 14px 16px;
        border-bottom: 1px solid #e0e0e0;
        color: #333;
        font-size: 0.95em;
    `;

    // Function to load players for seeding
    function loadPlayers() {
        const category = document.getElementById('seedingCategorySelect').value;
        console.log('loadPlayers called with category:', category);
        
        if (!category) {
            document.getElementById('playersContainer').style.display = 'none';
            return;
        }
        
        // Force refresh to ensure we get the latest seeding data
        console.log('Forcing refresh to get latest seeding data...');

        // Show loading state
        const tbody = document.getElementById('playersTableBody');
        tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px;">Loading players...</td></tr>';
        document.getElementById('playersContainer').style.display = 'block';

        const url = `/tournament/${tournamentId}/get_category_players/${category}?fields=full&t=${Date.now()}`;
        console.log('Fetching players from:', url);
        console.log('Timestamp added to prevent caching:', Date.now());
        
        fetch(url)
            .then(response => response.json())
            .then(data => {
                console.log('Received players data:', data);
                if (data.success) {
                    // Debug: Show seeding values
                    console.log('Player seeding values from database:');
                    data.players.forEach(player => {
                        console.log(`${player.name}: seeding = ${player.seeding}`);
                    });
                    
                    // Clear the table
                    tbody.innerHTML = '';

                    // Fetch rankings for the category
                    fetch('/get_rankings')
                        .then(response => response.json())
                        .then(rankingsData => {
                            console.log('Received rankings data:', rankingsData);
                            
                            // Add ranking to each player and sort by ranking
                            const playersWithRankings = data.players.map(player => ({
                                ...player,
                                ranking: getPlayerRanking(player.player_id, category, rankingsData),
                                originalSeed: player.seeding || ''
                            }));

                            // Store globally for validation
                            window.currentPlayersWithRankings = playersWithRankings;

                            // Check if any players have seeds
                            const hasSeeds = playersWithRankings.some(player => player.seeding && player.seeding.trim() !== '');
                            
                            if (hasSeeds) {
                                // If seeds exist, sort by existing seeding first, then by ranking for unseeded players
                                playersWithRankings.sort((a, b) => {
                                    const seedA = parseInt(a.seeding) || 999999;
                                    const seedB = parseInt(b.seeding) || 999999;
                                    
                                    // If both have seeds, sort by seed
                                    if (seedA !== 999999 && seedB !== 999999) {
                                        return seedA - seedB;
                                    }
                                    // If only one has seed, prioritize the seeded one
                                    if (seedA !== 999999) return -1;
                                    if (seedB !== 999999) return 1;
                                    // If neither has seed, sort by ranking
                                    const rankA = parseInt(a.ranking) || 999999;
                                    const rankB = parseInt(b.ranking) || 999999;
                                    return rankA - rankB;
                                });
                            } else {
                                // If no seeds exist, sort by ranking (ascending)
                                playersWithRankings.sort((a, b) => {
                                    const rankA = parseInt(a.ranking) || 999999;
                                    const rankB = parseInt(b.ranking) || 999999;
                                    return rankA - rankB;
                                });
                            }

                            // Show the reset seeds button
                            document.getElementById('resetSeedsButton').style.display = 'block';

                            // Remove any existing event listener for reset seeds button
                            const resetButton = document.getElementById('resetSeedsButton');
                            const newResetButton = resetButton.cloneNode(true);
                            resetButton.parentNode.replaceChild(newResetButton, resetButton);

                            // Add event listener for reset seeds button
                            newResetButton.addEventListener('click', function() {
                                // Ask for confirmation before resetting
                                if (!confirm('Are you sure you want to reset all seeds based on rankings? This will overwrite any manual changes you have made.')) {
                                    return;
                                }
                                
                                const seedingInputs = document.querySelectorAll('.seeding-input');
                                const players = Array.from(seedingInputs).map(input => {
                                    const row = input.closest('tr');
                                    const rankText = row.cells[1].textContent.trim();
                                    return {
                                        input: input,
                                        rank: rankText ? parseInt(rankText) : null
                                    };
                                });

                                // Sort players by ranking
                                players.sort((a, b) => {
                                    if (a.rank === null && b.rank === null) return 0;
                                    if (a.rank === null) return 1;
                                    if (b.rank === null) return -1;
                                    return a.rank - b.rank;
                                });

                                // Assign sequential seeds starting from 1
                                let currentSeed = 1;
                                let lastRank = null;

                                players.forEach((player, index) => {
                                    if (player.rank === null) {
                                        // Clear seeding for unranked players
                                        player.input.value = '';
                                        player.input.dataset.originalSeed = '';
                                    } else {
                                        // If this is a new rank (different from the last one), increment the seed
                                        if (player.rank !== lastRank) {
                                            currentSeed = index + 1;
                                        }
                                        // Assign the current seed (same for players with same rank)
                                        player.input.value = currentSeed.toString();
                                        player.input.dataset.originalSeed = currentSeed.toString();
                                        lastRank = player.rank;
                                    }
                                });

                                // Sort the table to show the new order
                                sortTableBySeed();

                                // Show success message
                                const messageBox = document.getElementById('messageBox');
                                messageBox.className = 'message success-message';
                                messageBox.textContent = 'Seeds have been reset based on rankings!';
                                messageBox.style.display = 'block';
                                setTimeout(() => {
                                    messageBox.style.display = 'none';
                                }, 3000);
                            });

                            // Generate default seeding based on rankings only for players without existing seeding
                            playersWithRankings.forEach((player, index) => {
                                const row = document.createElement('tr');
                                row.innerHTML = `
                                    <td style="${cellStyle}">${player.name}</td>
                                    <td style="${cellStyle}">${player.ranking || ''}</td>
                                    <td style="${cellStyle}">
                                        <input type="number" 
                                               class="form-control seeding-input" 
                                               value="${player.seeding || ''}" 
                                               min="1"
                                               max="${playersWithRankings.length}"
                                               name="seedings[]"
                                               data-player-id="${player.player_id}"
                                               data-original-seed="${player.seeding || ''}"
                                               style="width: 80px;">
                                    </td>
                                `;
                                tbody.appendChild(row);
                            });

                            // Add event listeners to seeding inputs
                            const seedingInputs = document.querySelectorAll('.seeding-input');
                            seedingInputs.forEach(input => {
                                const newInput = input.cloneNode(true);
                                input.parentNode.replaceChild(newInput, input);
                                newInput.addEventListener('change', handleSeedingChange);
                            });

                            // Show both buttons after loading players
                            document.getElementById('saveButton').style.display = 'inline-block';
                            document.getElementById('resetSeedsButton').style.display = 'inline-block';
                        })
                        .catch(error => {
                            console.error('Error fetching rankings:', error);
                            // If rankings fetch fails, still show players without rankings
                            tbody.innerHTML = '';
                            data.players.forEach((player, index) => {
                                const row = document.createElement('tr');
                                const seedRangeClass = getSeedRangeClass(index + 1, seedRanges);
                                row.className = seedRangeClass;
                                row.innerHTML = `
                                    <td style="${cellStyle}; text-align: center;">${index + 1}</td>
                                    <td style="${cellStyle}">${player.name}</td>
                                    <td style="${cellStyle}">${player.seeding || ''}</td>
                                `;
                                tbody.appendChild(row);
                            });

                            // Add event listeners to seeding inputs
                            const seedingInputs = document.querySelectorAll('.seeding-input');
                            seedingInputs.forEach(input => {
                                input.addEventListener('change', handleSeedingChange);
                            });

                            // Show both buttons after loading players
                            document.getElementById('saveButton').style.display = 'inline-block';
                            document.getElementById('resetSeedsButton').style.display = 'inline-block';
                        });
                } else {
                    console.error('Failed to load players:', data.message);
                    alert('Error loading players: ' + (data.message || 'Unknown error'));
                }
            })
            .catch(error => {
                console.error('Error loading players:', error);
                alert('Error loading players. Please try again.');
            });
    }

    // Function to adjust seedings to remove gaps while preserving duplicates
    function adjustSeedings() {
        const allInputs = Array.from(document.querySelectorAll('.seeding-input'));
        const validInputs = allInputs.filter(input => input.value.trim() !== '');
        
        // Sort inputs by their current seeding value
        validInputs.sort((a, b) => {
            const seedA = parseInt(a.value) || 0;
            const seedB = parseInt(b.value) || 0;
            return seedA - seedB;
        });

        let currentSeed = 1;
        let lastSeed = null;
        let duplicateCount = 0;
        let duplicateValue = null;

        validInputs.forEach((input, index) => {
            const thisSeed = parseInt(input.value);
            
            if (lastSeed === null) {
                // First player
                input.value = currentSeed.toString();
                input.dataset.originalSeed = currentSeed.toString();
                lastSeed = thisSeed;
                duplicateValue = currentSeed;
            } else if (thisSeed === lastSeed) {
                // Handle duplicate seeding
                input.value = duplicateValue.toString();
                input.dataset.originalSeed = duplicateValue.toString();
                duplicateCount++;
            } else {
                // New seeding value
                currentSeed = currentSeed + duplicateCount + 1;
                input.value = currentSeed.toString();
                input.dataset.originalSeed = currentSeed.toString();
                lastSeed = thisSeed;
                duplicateValue = currentSeed;
                duplicateCount = 0;
            }
        });
    }

    // Function to handle seeding changes
    function handleSeedingChange(event) {
        const input = event.target;
        const newSeedStr = input.value.trim();
        const newSeed = newSeedStr ? parseInt(newSeedStr) : null;
        const originalSeed = input.dataset.originalSeed ? parseInt(input.dataset.originalSeed) : null;
        
        // Get total number of players
        const totalPlayers = document.querySelectorAll('.seeding-input').length;
        
        // If the input is empty, handle removing seeding
        if (newSeedStr === '') {
            input.dataset.originalSeed = '';
            adjustSeedings();
            return;
        }
        
        // Validate the new seed if it's not empty
        if (isNaN(newSeed) || newSeed < 1 || newSeed > totalPlayers) {
            input.value = originalSeed || '';
            const messageBox = document.getElementById('messageBox');
            messageBox.className = 'message error-message';
            messageBox.textContent = `Seeding must be between 1 and ${totalPlayers}`;
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, 3000);
            return;
        }

        // Get all seeding inputs and their values
        const allInputs = Array.from(document.querySelectorAll('.seeding-input'));
        const validInputs = allInputs.filter(inp => inp.value.trim() !== '');
        
        // If moving to a lower seed, increment all seeds greater than the new seed
        if (originalSeed && newSeed < originalSeed) {
            validInputs.forEach(inp => {
                const currentSeed = parseInt(inp.value);
                if (currentSeed > newSeed && currentSeed <= originalSeed && inp !== input) {
                    inp.value = (currentSeed + 1).toString();
                    inp.dataset.originalSeed = inp.value;
                }
            });
        }
        // If moving to a higher seed, decrement seeds that were less than new seed
        else if (originalSeed && newSeed > originalSeed) {
            validInputs.forEach(inp => {
                const currentSeed = parseInt(inp.value);
                if (currentSeed < newSeed && currentSeed > originalSeed && inp !== input) {
                    inp.value = (currentSeed - 1).toString();
                    inp.dataset.originalSeed = inp.value;
                }
            });
        }

        // Update the seed value
        input.value = newSeed;
        input.dataset.originalSeed = newSeed;
        
        // Adjust all seedings to remove gaps while preserving duplicates
        adjustSeedings();
        
        // Auto-sort the table by seed values
        sortTableBySeed();
    }

    // Function to sort table by seed values
    function sortTableBySeed() {
        console.log('sortTableBySeed() function called');
        const tbody = document.getElementById('playersTableBody');
        if (!tbody) {
            console.error('playersTableBody not found!');
            return;
        }
        
        const rows = Array.from(tbody.getElementsByTagName('tr'));
        console.log(`Found ${rows.length} rows in the table`);
        
        // Get all rows with their seed values and rankings
        const rowsWithData = rows.map(row => {
            const seedInput = row.querySelector('.seeding-input');
            const seedValue = seedInput ? (parseInt(seedInput.value) || 999999) : 999999;
            const rankCell = row.cells[1]; // Second column contains ranking
            const rankValue = rankCell ? (parseInt(rankCell.textContent) || 999999) : 999999;
            return { row, seed: seedValue, rank: rankValue };
        });
        
        console.log('Rows with data:', rowsWithData.map(d => ({ seed: d.seed, rank: d.rank })));
        
        // Check if any players have seeds
        const hasSeeds = rowsWithData.some(rowData => rowData.seed !== 999999);
        console.log('Has seeds:', hasSeeds);
        
        if (hasSeeds) {
            // If seeds exist, sort by seed value
            rowsWithData.sort((a, b) => {
                if (a.seed === 999999 && b.seed === 999999) return 0;
                if (a.seed === 999999) return 1;
                if (b.seed === 999999) return -1;
                return a.seed - b.seed;
            });
        } else {
            // If no seeds exist, sort by ranking
            rowsWithData.sort((a, b) => {
                if (a.rank === 999999 && b.rank === 999999) return 0;
                if (a.rank === 999999) return 1;
                if (b.rank === 999999) return -1;
                return a.rank - b.rank;
            });
        }
        
        // Reorder the rows in the table
        rowsWithData.forEach(({ row }) => {
            tbody.appendChild(row);
        });
        
        console.log('Table rows reordered successfully');
        console.log('After sorting:', rowsWithData.map(d => ({ seed: d.seed, rank: d.rank })));
        
        // FLIP Animation: Show rows actually moving
        requestAnimationFrame(() => {
            // 1. FIRST: Capture current positions
            const firstRects = {};
            rowsWithData.forEach((data, index) => {
                const playerId = data.row.querySelector('[data-player-id]')?.dataset.playerId;
                if (playerId) {
                    firstRects[playerId] = data.row.getBoundingClientRect();
                }
            });
            
            // 2. LAST: Get new positions after DOM update
            requestAnimationFrame(() => {
                const lastRects = {};
                rowsWithData.forEach((data, index) => {
                    const playerId = data.row.querySelector('[data-player-id]')?.dataset.playerId;
                    if (playerId) {
                        lastRects[playerId] = data.row.getBoundingClientRect();
                    }
                });
                
                // 3. INVERT: Move rows back to old positions
                const moveList = [];
                rowsWithData.forEach((data, index) => {
                    const playerId = data.row.querySelector('[data-player-id]')?.dataset.playerId;
                    if (playerId && firstRects[playerId] && lastRects[playerId]) {
                        const dy = firstRects[playerId].top - lastRects[playerId].top;
                        if (dy !== 0) {
                            data.row.style.transition = 'none';
                            data.row.style.transform = `translateY(${dy}px)`;
                            data.row.style.backgroundColor = '#ffeb3b';
                            moveList.push({ row: data.row, dy });
                        }
                    }
                });
                
                // 4. PLAY: Animate to new positions sequentially
                let i = 0;
                function animateNext() {
                    if (i >= moveList.length) {
                        return;
                    }
                    const { row } = moveList[i];
                    row.style.transition = 'transform 800ms cubic-bezier(0.4,0,0.2,1), background-color 800ms ease';
                    row.style.transform = '';
                    
                    // Remove highlight after animation
                    setTimeout(() => {
                        row.style.backgroundColor = '';
                    }, 800);
                    
                    i++;
                    setTimeout(animateNext, 500); // 500ms delay between each row
                }
                animateNext();
            });
        });
        
        console.log('Table sorted successfully');
        
        // Update color coding based on new S.No. positions
        updateColorCodingAfterSort();
        
        // Update clash detection based on current input values
        updateClashDetection();
    }

    // Function to save seeding
    function saveSeeding(event) {
        event.preventDefault();
        const formData = new FormData();
        const category = document.getElementById('seedingCategorySelect').value;
        
        // Get all seeding inputs from the entire document
        const seedingInputs = document.querySelectorAll('.seeding-input');
        
        // Debug log to check what we're sending
        console.log('Saving seeding values:');
        seedingInputs.forEach(input => {
            console.log(`Player ID: ${input.dataset.playerId}, Seeding: ${input.value}`);
            formData.append('player_ids[]', input.dataset.playerId);
            formData.append('seedings[]', input.value);
        });
        formData.append('category', category);

        const saveButton = document.getElementById('saveButton');
        const messageBox = document.getElementById('messageBox');
        
        saveButton.disabled = true;
        messageBox.style.display = 'none';

        // Log the form data being sent
        console.log('FormData contents:');
        for (let pair of formData.entries()) {
            console.log(pair[0] + ': ' + pair[1]);
        }

        // Use the same endpoint as Step 2 to ensure consistency
        fetch(`/tournament/${tournamentId}/update_seeding`, {
            method: 'POST',
            body: formData
        })
        .then(response => response.json())
        .then(data => {
            saveButton.disabled = false;
            
            if (data.success) {
                messageBox.className = 'message success-message';
                messageBox.textContent = data.message || 'Seeding saved successfully!';
                
                // Update original seed values to reflect saved state
                seedingInputs.forEach(input => {
                    input.dataset.originalSeed = input.value;
                });
                
                console.log('Save successful, reloading table data...');
                
                // Reload the table data from server to show the updated sorted order
                const category = document.getElementById('seedingCategorySelect').value;
                if (category) {
                    // Force reload players to get the updated data from server
                    loadPlayers();
                } else {
                    // Fallback: try to sort locally
                    setTimeout(() => {
                        console.log('Calling sortTableBySeed() as fallback...');
                        sortTableBySeed();
                    }, 100);
                }
            } else {
                messageBox.className = 'message error-message';
                messageBox.textContent = data.message || 'Error saving seeding. Please try again.';
            }
            
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, 5000);
        })
        .catch(error => {
            console.error('Error saving seeding:', error);
            saveButton.disabled = false;
            messageBox.className = 'message error-message';
            messageBox.textContent = 'Error saving seeding. Please try again.';
            messageBox.style.display = 'block';
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, 5000);
        });
    }

    function getPlayerRanking(playerId, category, rankingsData) {
        // Find player's official state ID
        const playerData = rankingsData.players.find(p => p.player_id === playerId);
        if (!playerData || !playerData.official_state_id) return '';

        // Find ranking for this player and category
        const ranking = rankingsData.rankings.find(r => 
            r.official_state_id === playerData.official_state_id && 
            r.category === category
        );

        return ranking ? ranking.ranking : '';
    }

    // Function to show step content
    function showStepContent(stepNumber) {
        // Hide all step content areas
        document.querySelectorAll('.step-content-area').forEach(content => {
            content.style.display = 'none';
        });
        
        // Show selected step content
        document.getElementById(`step${stepNumber}Content`).style.display = 'block';
        
        // Update step items styling
        document.querySelectorAll('.step-item').forEach((item, index) => {
            if (index + 1 === stepNumber) {
                item.style.background = '#e9ecef';
                item.style.borderColor = '#1e3c72';
            } else {
                item.style.background = '#f8f9fa';
                item.style.borderColor = '#e9ecef';
            }
        });

        // Initialize event listeners for the current step
        if (stepNumber === 1) {
            // Auto-refresh players when switching to Step 1
            const seedingCategorySelect = document.getElementById('seedingCategorySelect');
            const clashCategorySelect = document.getElementById('clashCategorySelect');
            
            console.log('Switching to Step 1 - Update Seeding');
            console.log('Clash category value:', clashCategorySelect ? clashCategorySelect.value : 'null');
            console.log('Seeding category value:', seedingCategorySelect ? seedingCategorySelect.value : 'null');
            
            // Sync category selection between Step 2 and Step 1
            if (clashCategorySelect && clashCategorySelect.value && seedingCategorySelect) {
                // If Step 2 has a category selected, use it in Step 1
                if (seedingCategorySelect.value !== clashCategorySelect.value) {
                    console.log('Syncing category from Step 2 to Step 1:', clashCategorySelect.value);
                    seedingCategorySelect.value = clashCategorySelect.value;
                }
                // Force refresh players with the selected category (clear cache)
                console.log('Force refreshing players for Step 1 with category:', seedingCategorySelect.value);
                // Clear any cached data and reload
                const tbody = document.getElementById('playersTableBody');
                if (tbody) {
                    tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px; color: #1e3c72;">Refreshing data...</td></tr>';
                }
                // Add a small delay to ensure the UI updates before loading fresh data
                setTimeout(() => {
                    loadPlayers();
                }, 100);
            } else if (seedingCategorySelect && seedingCategorySelect.value) {
                // If Step 1 already has a category selected, refresh the data
                console.log('Refreshing players for Step 1 with existing category:', seedingCategorySelect.value);
                loadPlayers();
            } else {
                console.log('No category selected in either step');
            }
            
            // Sync with Create Draw view
            const drawCategorySelect = document.getElementById('drawCategorySelect');
            if (drawCategorySelect && clashCategorySelect && clashCategorySelect.value) {
                if (drawCategorySelect.value !== clashCategorySelect.value) {
                    console.log('Syncing category from Step 2 to Create Draw:', clashCategorySelect.value);
                    drawCategorySelect.value = clashCategorySelect.value;
                    // Trigger the change event to load players
                    const event = new Event('change');
                    drawCategorySelect.dispatchEvent(event);
                }
            }
            
            if (drawCategorySelect) {
                drawCategorySelect.removeEventListener('change', handleDrawCategoryChange);
                drawCategorySelect.addEventListener('change', handleDrawCategoryChange);
            }
        } else if (stepNumber === 2) {
            // Auto-refresh clash players when switching to Step 2
            const clashCategorySelect = document.getElementById('clashCategorySelect');
            const seedingCategorySelect = document.getElementById('seedingCategorySelect');
            
            // Sync category selection between Step 1 and Step 2
            if (seedingCategorySelect && seedingCategorySelect.value && clashCategorySelect) {
                // If Step 1 has a category selected, use it in Step 2
                if (clashCategorySelect.value !== seedingCategorySelect.value) {
                    clashCategorySelect.value = seedingCategorySelect.value;
                }
                // Load clash players with the selected category
                loadClashPlayers();
            } else if (clashCategorySelect && clashCategorySelect.value) {
                // If Step 2 already has a category selected, refresh the data
                loadClashPlayers();
            }
            
            // Sync with Create Draw view
            const drawCategorySelect = document.getElementById('drawCategorySelect');
            if (drawCategorySelect && clashCategorySelect && clashCategorySelect.value) {
                if (drawCategorySelect.value !== clashCategorySelect.value) {
                    console.log('Syncing category from Step 2 to Create Draw:', clashCategorySelect.value);
                    drawCategorySelect.value = clashCategorySelect.value;
                    // Trigger the change event to load players
                    const event = new Event('change');
                    drawCategorySelect.dispatchEvent(event);
                }
            }
            
            if (drawCategorySelect) {
                drawCategorySelect.removeEventListener('change', handleDrawCategoryChange);
                drawCategorySelect.addEventListener('change', handleDrawCategoryChange);
            }
        } else if (stepNumber === 3) {
            // Auto-sync category selection when switching to Step 3 (Create Draws)
            const drawCategorySelect = document.getElementById('drawCategorySelect');
            const seedingCategorySelect = document.getElementById('seedingCategorySelect');
            const clashCategorySelect = document.getElementById('clashCategorySelect');
            
            console.log('Switching to Step 3 - Create Draws');
            
            // Sync category selection from Step 1 (if available)
            if (seedingCategorySelect && seedingCategorySelect.value && drawCategorySelect) {
                if (drawCategorySelect.value !== seedingCategorySelect.value) {
                    console.log('Syncing category from Step 1 to Create Draw:', seedingCategorySelect.value);
                    drawCategorySelect.value = seedingCategorySelect.value;
                    // Force refresh with cache busting
                    setTimeout(() => {
                        const event = new Event('change');
                        drawCategorySelect.dispatchEvent(event);
                    }, 100);
                }
            }
            
            // Sync with Create Draw view from Step 2 (clash resolution)
            if (drawCategorySelect && clashCategorySelect && clashCategorySelect.value) {
                if (drawCategorySelect.value !== clashCategorySelect.value) {
                    console.log('Syncing category from Step 2 to Create Draw:', clashCategorySelect.value);
                    drawCategorySelect.value = clashCategorySelect.value;
                    // Force refresh with cache busting to ensure updated seedings are loaded
                    setTimeout(() => {
                        const event = new Event('change');
                        drawCategorySelect.dispatchEvent(event);
                    }, 100);
                } else if (drawCategorySelect.value === clashCategorySelect.value) {
                    // Even if the category is the same, force refresh to get updated seedings
                    console.log('Forcing refresh of existing category to get updated seedings');
                    setTimeout(() => {
                        const event = new Event('change');
                        drawCategorySelect.dispatchEvent(event);
                    }, 100);
                }
            }
            
            if (drawCategorySelect) {
                drawCategorySelect.removeEventListener('change', handleDrawCategoryChange);
                drawCategorySelect.addEventListener('change', handleDrawCategoryChange);
            }
        } else if (stepNumber === 4) {
            // Auto-sync category selection when switching to Step 4 (Create Brackets)
            const categorySelect = document.getElementById('categorySelect');
            const seedingCategorySelect = document.getElementById('seedingCategorySelect');
            const clashCategorySelect = document.getElementById('clashCategorySelect');
            const drawCategorySelect = document.getElementById('drawCategorySelect');
            
            console.log('Switching to Step 4 - Create Brackets');
            
            // Find the last selected category from other steps
            let lastSelectedCategory = null;
            
            if (seedingCategorySelect && seedingCategorySelect.value) {
                lastSelectedCategory = seedingCategorySelect.value;
                console.log('Found category from Step 1:', lastSelectedCategory);
            }
            if (clashCategorySelect && clashCategorySelect.value) {
                lastSelectedCategory = clashCategorySelect.value;
                console.log('Found category from Step 2:', lastSelectedCategory);
            }
            if (drawCategorySelect && drawCategorySelect.value) {
                lastSelectedCategory = drawCategorySelect.value;
                console.log('Found category from Step 3:', lastSelectedCategory);
            }
            
            // Sync category to Create Brackets if found
            if (lastSelectedCategory && categorySelect) {
                if (categorySelect.value !== lastSelectedCategory) {
                    console.log('Syncing category to Create Brackets:', lastSelectedCategory);
                    categorySelect.value = lastSelectedCategory;
                    // Enable the generate button
                    const generateBtn = document.getElementById('generateBracket');
                    if (generateBtn) {
                        generateBtn.disabled = false;
                    }
                }
            }
        }
    }

    // Function to handle category change in Step 2 (Seeding Clash Resolution)
    function handleCategoryChange() {
        const category = this.value;
        if (category) {
            // Show loading message
            document.getElementById('players-table-container').innerHTML = '<p style="color:#1e3c72;">Loading players...</p>';
            document.getElementById('editable-table-container').innerHTML = '';
            document.getElementById('create-draw-btn').style.display = 'none';
            document.getElementById('save-draw-btn').style.display = 'none';
            document.getElementById('stop-shuffle-btn').style.display = 'none';
            document.getElementById('status-message').style.display = 'none';
            
            // Fetch players for the selected category
            const url = `/tournament/{{ tournament['Tournament Id'] }}/get_category_players/${encodeURIComponent(category)}?fields=full&t=${Date.now()}`;
            console.log('Fetching players from:', url);
            
            fetch(url)
                .then(response => {
                    console.log('Response status:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('Received data:', data);
                    if (data.success && data.players && data.players.length > 0) {
                        currentPlayers = data.players.map(player => ({...player}));
                        console.log('Processed players:', currentPlayers);
                        createAndDisplayTables(currentPlayers);
                    } else {
                        console.log('No players found or invalid data');
                        document.getElementById('players-table-container').innerHTML = '<p style="color:#b00;">No players found for this category.</p>';
                        document.getElementById('editable-table-container').innerHTML = '';
                        document.getElementById('create-draw-btn').style.display = 'none';
                        document.getElementById('save-draw-btn').style.display = 'none';
                        document.getElementById('stop-shuffle-btn').style.display = 'none';
                    }
                })
                .catch(error => {
                    console.error('Error fetching players:', error);
                    document.getElementById('players-table-container').innerHTML = '<p style="color:#b00;">Error loading players</p>';
                });
        } else {
            document.getElementById('players-table-container').innerHTML = '';
            document.getElementById('editable-table-container').innerHTML = '';
            document.getElementById('create-draw-btn').style.display = 'none';
            document.getElementById('save-draw-btn').style.display = 'none';
            document.getElementById('stop-shuffle-btn').style.display = 'none';
            document.getElementById('status-message').style.display = 'none';
        }
    }

    // Function to handle category change in Step 3 (Create Draws)
    function handleDrawCategoryChange() {
        const category = this.value;
        if (category) {
            // Show loading message
            document.getElementById('drawPlayersContainer').style.display = 'block';
            const tbody = document.getElementById('drawPlayersTableBody');
            tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 20px;">Loading players...</td></tr>';
            document.getElementById('create-draw-btn').style.display = 'none';
            document.getElementById('save-draw-btn').style.display = 'none';
            document.getElementById('stop-shuffle-btn').style.display = 'none';
            document.getElementById('status-message').style.display = 'none';
            
            // Fetch players for the selected category with cache busting
            const url = `/tournament/{{ tournament['Tournament Id'] }}/get_category_players/${encodeURIComponent(category)}?fields=full&t=${Date.now()}`;
            console.log('Fetching players for draw creation from:', url);
            
            fetch(url)
                .then(response => {
                    console.log('Response status for draw creation:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('Received data for draw creation:', data);
                    if (data.success && data.players && data.players.length > 0) {
                        console.log('Players loaded successfully for draw creation:', data.players.length);
                        displayDrawPlayers(data.players, document.getElementById('drawGroupSelect').value);
                        // Show the create draw button
                        document.getElementById('create-draw-btn').style.display = 'block';
                    } else {
                        console.log('No players found or invalid data for draw creation');
                        tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 20px;">No players found for this category</td></tr>';
                        document.getElementById('create-draw-btn').style.display = 'none';
                        document.getElementById('save-draw-btn').style.display = 'none';
                        document.getElementById('stop-shuffle-btn').style.display = 'none';
                    }
                })
                .catch(error => {
                    console.error('Error fetching players for draw creation:', error);
                    tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 20px;">Error loading players</td></tr>';
                });
        } else {
            document.getElementById('drawPlayersContainer').style.display = 'none';
            document.getElementById('create-draw-btn').style.display = 'none';
            document.getElementById('save-draw-btn').style.display = 'none';
            document.getElementById('stop-shuffle-btn').style.display = 'none';
            document.getElementById('status-message').style.display = 'none';
        }
    }

    // Function to create and display tables
    function createAndDisplayTables(players) {
        // Sort players by seeding
        players.sort((a, b) => {
            const seedA = parseInt(a.seeding) || 999999;
            const seedB = parseInt(b.seeding) || 999999;
            return seedA - seedB;
        });

        // Common table styles
        const tableStyle = `
            width: 100%;
            margin-bottom: 20px;
            border-collapse: collapse;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            border-radius: 8px;
            overflow: hidden;
        `;
        
        const headerStyle = `
            padding: 16px;
            text-align: left;
            background: #1e3c72;
            color: white;
            font-weight: 500;
            font-size: 0.95em;
            border-bottom: 2px solid #2a5298;
        `;
        
        const cellStyle = `
            padding: 14px 16px;
            border-bottom: 1px solid #e0e0e0;
            color: #333;
            font-size: 0.95em;
        `;
        
        const rankCellStyle = `
            padding: 14px 16px;
            border-bottom: 1px solid #e0e0e0;
            text-align: center;
            background: #f0f5ff;
            color: #1e3c72;
            font-weight: 600;
            font-size: 0.95em;
            width: 60px;
        `;

        // Create the left table (original players)
        const leftTable = document.createElement('table');
        leftTable.className = 'table table-striped';
        leftTable.style.cssText = tableStyle;
        leftTable.innerHTML = `
            <thead>
                <tr>
                    <th style="${headerStyle}">Seed</th>
                    <th style="${headerStyle}">Name</th>
                    <th style="${headerStyle}">School/Institution</th>
                </tr>
            </thead>
            <tbody>
                ${players.map((player, idx) => `
                    <tr>
                        <td style="${cellStyle}">${player.seeding || ''}</td>
                        <td style="${cellStyle}">${player.name}</td>
                        <td style="${cellStyle}">${player.school || ''}</td>
                    </tr>
                `).join('')}
            </tbody>
        `;
        
        // Create the right table (editable draw)
        const rightTable = document.createElement('table');
        rightTable.className = 'table table-striped';
        rightTable.id = 'editable-table';
        rightTable.style.cssText = tableStyle;
        rightTable.innerHTML = `
            <thead>
                <tr>
                    <th style="${headerStyle}">Seed</th>
                    <th style="${headerStyle}">Name</th>
                    <th style="${headerStyle}">School/Institution</th>
                </tr>
            </thead>
            <tbody>
                ${players.map((player, idx) => `
                    <tr>
                        <td style="${cellStyle}">${player.seeding || ''}</td>
                        <td style="${cellStyle}">${player.name}</td>
                        <td style="${cellStyle}">${player.school || ''}</td>
                    </tr>
                `).join('')}
            </tbody>
        `;
        
        // Update the containers with consistent styling
        const leftContainer = document.getElementById('players-table-container');
        const rightContainer = document.getElementById('editable-table-container');
        
        leftContainer.innerHTML = '';
        leftContainer.appendChild(leftTable);
        rightContainer.innerHTML = '';
        rightContainer.appendChild(rightTable);
        
        // Add hover effect to rows
        const allRows = document.querySelectorAll('table tbody tr');
        allRows.forEach(row => {
            row.style.transition = 'background-color 0.2s ease';
            row.addEventListener('mouseover', () => {
                row.style.backgroundColor = '#f8f9fa';
            });
            row.addEventListener('mouseout', () => {
                row.style.backgroundColor = '';
            });
        });
        
        // Show the create draw button
        document.getElementById('create-draw-btn').style.display = 'block';
        console.log('Tables created and displayed');
    }

    // Function to start shuffling
    function startShuffling() {
        if (!currentPlayers.length) {
            showStatusMessage('Please select a category first!', 'error');
            return;
        }

        // First fetch the seeding ranges
        fetch('/get_seeding_ranges')
            .then(response => response.json())
            .then(seedRangesData => {
                if (!seedRangesData.success) {
                    console.error('Failed to get seeding ranges');
                    return;
                }
                const seedRanges = seedRangesData.seeding_ranges;
                console.log('Loaded seed ranges from JSON:', seedRanges);

                // Now fetch players with rankings
                fetch(`/tournament/${tournamentId}/get_category_players/${category}?fields=full&t=${Date.now()}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Fetch rankings for the category
                            fetch('/get_rankings')
                                .then(response => response.json())
                                .then(rankingsData => {
                                    console.log('Received rankings data:', rankingsData);
                                    
                                    // Add ranking to each player and sort by ranking
                                    const playersWithRankings = data.players.map(player => ({
                                        ...player,
                                        ranking: getPlayerRanking(player.player_id, category, rankingsData),
                                        originalSeed: player.seeding || ''
                                    }));

                                    // Store globally for validation
                                    window.currentPlayersWithRankings = playersWithRankings;

                                    // Sort players by seed (ascending)
                                    playersWithRankings.sort((a, b) => {
                                        const seedA = parseInt(a.seeding) || 999999;
                                        const seedB = parseInt(b.seeding) || 999999;
                                        return seedA - seedB;
                                    });

                                    // Clear the table
                                    tbody.innerHTML = '';

                                    // Build clash players set once before processing players
                                    const initialClashes = detectSeedingClashes(playersWithRankings, seedRanges);
                                    window.clashPlayersSet = new Set();
                                    initialClashes.forEach(clash => {
                                        clash.players.forEach(pinfo => {
                                            window.clashPlayersSet.add(pinfo.player.player_id);
                                        });
                                    });
                                    console.log('Clash players set created:', Array.from(window.clashPlayersSet));

                                    // Add players to the table
                                    playersWithRankings.forEach((player, index) => {
                                        const row = document.createElement('tr');
                                        const seedRangeClass = getSeedRangeClass(index + 1, seedRanges);
                                        row.className = seedRangeClass;
                                        
                                        // Check for seeding clashes
                                        const clashInfo = detectSeedingClash(player, playersWithRankings, index, seedRanges);
                                        let clashClass = '';
                                        let clashTooltip = '';
                                        let isClashPlayer = false;
                                        
                                        if (window.clashPlayersSet.has(player.player_id)) {
                                            isClashPlayer = true;
                                        }
                                        
                                        if (clashInfo.hasClash) {
                                            clashClass = 'seeding-clash-row';
                                            clashTooltip = `Seeding Clash: Player with seed ${player.seeding} appears on both sides of range boundary. Suggested resolution: ${clashInfo.suggestedSeeds.join(', ')}`;
                                        }
                                        
                                        row.className = seedRangeClass + (clashClass ? ' ' + clashClass : '');
                                        if (clashTooltip) {
                                            row.title = clashTooltip;
                                        }
                                        
                                        // Render seed as input if clash, else as text
                                        let seedCellHtml = '';
                                        if (isClashPlayer) {
                                            // Get valid range for this clash group
                                            const validRange = getValidSeedRangeForClash(playersWithRankings, player.seeding);
                                            // Build options for select
                                            let optionsHtml = '';
                                            for (let v = validRange.min; v <= validRange.max; v++) {
                                                optionsHtml += `<option value="${v}" ${parseInt(player.seeding) === v ? 'selected' : ''}>${v}</option>`;
                                            }
                                            
                                            // Add shuffle button in automatic mode
                                            let shuffleBtnHtml = '';
                                            if (window.clashResolutionMode === 'auto') {
                                                // Get color based on the seed value (not seeding group)
                                                const currentSeed = parseInt(player.seeding);
                                                const dynamicColor = getDynamicColorForSeed(currentSeed);
                                                
                                                shuffleBtnHtml = `<button class="resolve-clash-btn shuffle-btn" style="background-color: ${dynamicColor}; margin-left: 5px; font-size: 0.9em; padding: 4px 8px;" onclick="shuffleClashGroupByPlayer('${player.player_id}')" title="Shuffle this clash group">🔀</button>`;
                                                console.log('Adding shuffle button for player:', player.player_id, 'with seed:', currentSeed, 'color:', dynamicColor);
                                            } else {
                                                console.log('Not adding shuffle button - mode is:', window.clashResolutionMode);
                                            }
                                            
                                            seedCellHtml = `
                                                <span title="Clash!" style="color: #f44336; font-weight: bold;">⚠️</span>
                                                <select class="seed-input" style="width: 70px; margin-left: 5px;"
                                                    data-player-id="${player.player_id}"
                                                    data-valid-min="${validRange.min}"
                                                    data-valid-max="${validRange.max}"
                                                    onchange="(function(e){
                                                        if(validateSeedInput(e.target)){
                                                            sortTableBySeed();
                                                        }
                                                    })(event)">
                                                    ${optionsHtml}
                                                </select>
                                                ${shuffleBtnHtml}
                                            `;
                                        } else {
                                            seedCellHtml = `${player.seeding || ''}`;
                                        }
                                        
                                        row.innerHTML = `
                                            <td style="${cellStyle}; text-align: center;">${index + 1}</td>
                                            <td style="${cellStyle}">${player.name}</td>
                                            <td style="${cellStyle}">${seedCellHtml}</td>
                                        `;
                                        tbody.appendChild(row);
                                    });
                                    
                                    // Show clash summary if any clashes detected
                                    const clashes = detectAllSeedingClashes(playersWithRankings, seedRanges);
                                    if (clashes.length > 0) {
                                        showClashSummary(clashes);
                                    } else {
                                        // Hide clash summary if no clashes detected
                                        const clashSummary = document.getElementById('clashSummary');
                                        clashSummary.style.display = 'none';
                                    }
                                })
                                .catch(error => {
                                    console.error('Error fetching rankings:', error);
                                    // If rankings fetch fails, still show players without rankings
                                    tbody.innerHTML = '';
                                    data.players.forEach((player, index) => {
                                        const row = document.createElement('tr');
                                        const seedRangeClass = getSeedRangeClass(index + 1, seedRanges);
                                        row.className = seedRangeClass;
                                        row.innerHTML = `
                                            <td style="${cellStyle}; text-align: center;">${index + 1}</td>
                                            <td style="${cellStyle}">${player.name}</td>
                                            <td style="${cellStyle}">${player.seeding || ''}</td>
                                        `;
                                        tbody.appendChild(row);
                                    });

                                    // Detect and highlight seeding clashes
                                    const clashes = detectSeedingClashes(playersWithRankings, seedRanges);
                                    if (clashes.length > 0) {
                                        highlightClashes(clashes);
                                        showClashSummary(clashes);
                                    }
                                });
                        } else {
                            console.error('Failed to load players:', data.message);
                            tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px; color: red;">Error loading players</td></tr>';
                        }
                    })
                    .catch(error => {
                        console.error('Error loading players:', error);
                        tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px; color: red;">Error loading players</td></tr>';
                    });
            })
            .catch(error => {
                console.error('Error fetching seed ranges:', error);
                // If seed ranges fetch fails, show players without colors
                loadPlayersWithoutSeedRanges(category);
            });
    }

    // Function to stop shuffling
    function stopShuffling() {
        isShuffling = false;
        clearInterval(shuffleInterval);
        clearTimeout(shuffleInterval); // Clear any pending timeouts
        
        // Update UI
        document.getElementById('create-draw-btn').style.display = 'none';
        document.getElementById('stop-shuffle-btn').style.display = 'none';
        document.getElementById('save-draw-btn').style.display = 'block';
        document.getElementById('shuffleCounter').style.display = 'none';
        
        // Remove any pending animations
        const editableTable = document.getElementById('editable-table');
        if (editableTable) {
            editableTable.classList.remove('highlight-animation');
        }
        
        showStatusMessage('Draw created! Click "Save Draw" to save it.', 'success');
    }

    // Function to perform shuffle
    function performShuffle() {
        if (!isShuffling) return;
        
        const editableTable = document.getElementById('editable-table');
        if (!editableTable) return;
        
        // Get all rows except header
        const rows = Array.from(editableTable.getElementsByTagName('tbody')[0].rows);
        
        // Group players by their seeding ranges
        const playersByRange = {};
        rows.forEach(row => {
            const seedingCell = row.cells[0]; // First cell contains seeding
            const seeding = parseInt(seedingCell.textContent) || 999999;
            
            // Find which range this player belongs to
            let rangeFound = false;
            for (const range of seedRanges) {
                if (seeding >= range.min && seeding <= range.max) {
                    if (!playersByRange[range.description]) {
                        playersByRange[range.description] = [];
                    }
                    playersByRange[range.description].push(row);
                    rangeFound = true;
                    break;
                }
            }
            
            // If no range found, put in unseeded
            if (!rangeFound) {
                if (!playersByRange['Unseeded']) {
                    playersByRange['Unseeded'] = [];
                }
                playersByRange['Unseeded'].push(row);
            }
        });
        
        // Shuffle players within each range
        for (const range in playersByRange) {
            const players = playersByRange[range];
            for (let i = players.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                const temp = players[i].innerHTML;
                players[i].innerHTML = players[j].innerHTML;
                players[j].innerHTML = temp;
            }
        }
        
        // Update shuffle counter
        shuffleCount++;
        const counter = document.getElementById('shuffleCounter');
        if (counter) {
            counter.textContent = `Shuffles: ${shuffleCount}`;
        }
        
        // Add animation class
        editableTable.classList.add('highlight-animation');
        setTimeout(() => {
            if (isShuffling) {
                editableTable.classList.remove('highlight-animation');
            }
        }, 50);

        // Schedule next shuffle with uniform interval
        if (isShuffling) {
            shuffleInterval = setTimeout(performShuffle, 100);
        }
    }

    // Function to save draw
    function saveDraw() {
        const drawData = [];
        const tournamentId = "{{ tournament['Tournament Id'] }}";
        const category = document.getElementById('drawCategorySelect').value;
        
        const editableTable = document.getElementById('editable-table');
        if (editableTable) {
            Array.from(editableTable.rows).forEach((row, index) => {
                if (index === 0) return; // Skip header row
                
                const seeding = row.cells[0].textContent;
                const name = row.cells[1].textContent;
                const school = row.cells[2].textContent;
                
                if (name.trim() !== '') {
                    drawData.push({
                        rank: index, // Use the row index as rank
                        seeding,
                        tournamentId,
                        name,
                        school,
                        category
                    });
                }
            });
        }
        
        if (drawData.length > 0) {
            fetch('/save_tournament_draw', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ 
                    drawData: drawData,
                    tournamentId: tournamentId,
                    category: category
                })
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    showStatusMessage('Draw saved successfully!', 'success');
                    // Enable next step
                    const createBracketsBtn = document.getElementById('createBracketsBtn');
                    if (createBracketsBtn) {
                        createBracketsBtn.disabled = false;
                    }
                } else {
                    showStatusMessage('Error: ' + data.message, 'error');
                }
            })
            .catch(error => {
                showStatusMessage('Error saving draw. Please try again.', 'error');
                console.error('Error saving draw:', error);
            });
        } else {
            showStatusMessage('No data to save. Please create a draw first.', 'error');
        }
    }

    // Function to show status message
    function showStatusMessage(message, type) {
        const statusMsg = document.getElementById('status-message');
        if (statusMsg) {
            statusMsg.textContent = message;
            statusMsg.className = 'status-message status-' + type;
            statusMsg.style.display = 'block';
            
            if (type === 'success') {
                setTimeout(() => {
                    statusMsg.style.display = 'none';
                }, 5000);
            }
        }
    }

    // Initialize event listeners when the page loads
    document.addEventListener('DOMContentLoaded', function() {
        // Initialize Step 1
        const seedingCategorySelect = document.getElementById('seedingCategorySelect');
        if (seedingCategorySelect) {
            seedingCategorySelect.addEventListener('change', function() {
                lastSelectedCategory = this.value;
                console.log('Category selected in Step 1:', lastSelectedCategory);
                loadPlayers();
            });
        }
        
        // Add event listener to refresh data when switching to Step 1 (Create Draws)
        const step1Tab = document.querySelector('a[href="#step1"]');
        if (step1Tab) {
            step1Tab.addEventListener('click', function() {
                console.log('Switched to Step 1 (Create Draws) - refreshing data...');
                // Force refresh the current category if one is selected
                if (lastSelectedCategory) {
                    setTimeout(() => {
                        loadPlayers();
                    }, 100);
                }
            });
        }

        // Initialize seeding form
        const seedingForm = document.getElementById('seedingForm');
        if (seedingForm) {
            seedingForm.addEventListener('submit', saveSeeding);
        }

        // Initialize Step 2 (Resolve Seeding Clash)
        const clashCategorySelect = document.getElementById('clashCategorySelect');
        if (clashCategorySelect) {
            clashCategorySelect.addEventListener('change', function() {
                lastSelectedCategory = this.value;
                console.log('Category selected in Step 2:', lastSelectedCategory);
                loadClashPlayers();
            });
        }

        // Initialize Step 3
        const drawCategorySelect = document.getElementById('drawCategorySelect');
        if (drawCategorySelect) {
            drawCategorySelect.addEventListener('change', function() {
                lastSelectedCategory = this.value;
                console.log('Category selected in Step 3:', lastSelectedCategory);
                handleDrawCategoryChange.call(this);
            });
        }

        const createDrawBtn = document.getElementById('create-draw-btn');
        if (createDrawBtn) {
            createDrawBtn.addEventListener('click', startShuffling);
        }

        const stopShuffleBtn = document.getElementById('stop-shuffle-btn');
        if (stopShuffleBtn) {
            stopShuffleBtn.addEventListener('click', stopShuffling);
        }

        const saveDrawBtn = document.getElementById('save-draw-btn');
        if (saveDrawBtn) {
            saveDrawBtn.addEventListener('click', saveDraw);
        }

        // Initialize Step 4 (Create Brackets)
        const categorySelect = document.getElementById('categorySelect');
        const generateBracketBtn = document.getElementById('generateBracket');
        
        if (categorySelect) {
            categorySelect.addEventListener('change', function() {
                lastSelectedCategory = this.value;
                console.log('Category selected in Step 4:', lastSelectedCategory);
                // Enable/disable generate button based on selection
                if (generateBracketBtn) {
                    generateBracketBtn.disabled = !this.value;
                }
            });
        }

        // Show the first step by default
        showStepContent(1);
    });

    // Function to load players for seeding clash resolution
    function loadClashPlayers() {
        const category = document.getElementById('clashCategorySelect').value;
        if (!category) {
            document.getElementById('clashContainer').style.display = 'none';
            return;
        }

        // Show loading state
        const tbody = document.getElementById('clashTableBody');
        tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px;">Loading players...</td></tr>';
        document.getElementById('clashContainer').style.display = 'block';

        // First fetch the seed ranges
        fetch('/get_seeding_ranges')
            .then(response => response.json())
            .then(seedRangesData => {
                if (!seedRangesData.success) {
                    console.error('Failed to get seeding ranges');
                    return;
                }
                const seedRanges = seedRangesData.seeding_ranges;
                console.log('Loaded seed ranges from JSON:', seedRanges);

                // Now fetch players with rankings
                fetch(`/tournament/${tournamentId}/get_category_players/${category}?fields=full&t=${Date.now()}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            // Fetch rankings for the category
                            fetch('/get_rankings')
                                .then(response => response.json())
                                .then(rankingsData => {
                                    console.log('Received rankings data:', rankingsData);
                                    
                                    // Add ranking to each player and sort by ranking
                                    const playersWithRankings = data.players.map(player => ({
                                        ...player,
                                        ranking: getPlayerRanking(player.player_id, category, rankingsData),
                                        originalSeed: player.seeding || ''
                                    }));

                                    // Store globally for validation
                                    window.currentPlayersWithRankings = playersWithRankings;

                                    // Sort players by seed (ascending)
                                    playersWithRankings.sort((a, b) => {
                                        const seedA = parseInt(a.seeding) || 999999;
                                        const seedB = parseInt(b.seeding) || 999999;
                                        return seedA - seedB;
                                    });

                                    // Clear the table
                                    tbody.innerHTML = '';

                                    // Build clash players set once before processing players
                                    const initialClashes = detectSeedingClashes(playersWithRankings, seedRanges);
                                    window.clashPlayersSet = new Set();
                                    initialClashes.forEach(clash => {
                                        clash.players.forEach(pinfo => {
                                            window.clashPlayersSet.add(pinfo.player.player_id);
                                        });
                                    });
                                    console.log('Clash players set created:', Array.from(window.clashPlayersSet));

                                    // Add players to the table
                                    playersWithRankings.forEach((player, index) => {
                                        const row = document.createElement('tr');
                                        const seedRangeClass = getSeedRangeClass(index + 1, seedRanges);
                                        row.className = seedRangeClass;
                                        
                                        // Check for seeding clashes
                                        const clashInfo = detectSeedingClash(player, playersWithRankings, index, seedRanges);
                                        let clashClass = '';
                                        let clashTooltip = '';
                                        let isClashPlayer = false;
                                        
                                        if (window.clashPlayersSet.has(player.player_id)) {
                                            isClashPlayer = true;
                                        }
                                        
                                        if (clashInfo.hasClash) {
                                            clashClass = 'seeding-clash-row';
                                            clashTooltip = `Seeding Clash: Player with seed ${player.seeding} appears on both sides of range boundary. Suggested resolution: ${clashInfo.suggestedSeeds.join(', ')}`;
                                        }
                                        
                                        row.className = seedRangeClass + (clashClass ? ' ' + clashClass : '');
                                        if (clashTooltip) {
                                            row.title = clashTooltip;
                                        }
                                        
                                        // Render seed as input if clash, else as text
                                        let seedCellHtml = '';
                                        if (isClashPlayer) {
                                            // Get valid range for this clash group
                                            const validRange = getValidSeedRangeForClash(playersWithRankings, player.seeding);
                                            // Build options for select
                                            let optionsHtml = '';
                                            for (let v = validRange.min; v <= validRange.max; v++) {
                                                optionsHtml += `<option value="${v}" ${parseInt(player.seeding) === v ? 'selected' : ''}>${v}</option>`;
                                            }
                                            
                                            // Add shuffle button in automatic mode
                                            let shuffleBtnHtml = '';
                                            if (window.clashResolutionMode === 'auto') {
                                                // Get color based on the seed value (not seeding group)
                                                const currentSeed = parseInt(player.seeding);
                                                const dynamicColor = getDynamicColorForSeed(currentSeed);
                                                
                                                shuffleBtnHtml = `<button class="resolve-clash-btn shuffle-btn" style="background-color: ${dynamicColor}; margin-left: 5px; font-size: 0.9em; padding: 4px 8px;" onclick="shuffleClashGroupByPlayer('${player.player_id}')" title="Shuffle this clash group">🔀</button>`;
                                                console.log('Adding shuffle button for player:', player.player_id, 'with seed:', currentSeed, 'color:', dynamicColor);
                                            } else {
                                                console.log('Not adding shuffle button - mode is:', window.clashResolutionMode);
                                            }
                                            
                                            seedCellHtml = `
                                                <span title="Clash!" style="color: #f44336; font-weight: bold;">⚠️</span>
                                                <select class="seed-input" style="width: 70px; margin-left: 5px;"
                                                    data-player-id="${player.player_id}"
                                                    data-valid-min="${validRange.min}"
                                                    data-valid-max="${validRange.max}"
                                                    onchange="(function(e){
                                                        if(validateSeedInput(e.target)){
                                                            sortTableBySeed();
                                                        }
                                                    })(event)">
                                                    ${optionsHtml}
                                                </select>
                                                ${shuffleBtnHtml}
                                            `;
                                        } else {
                                            seedCellHtml = `${player.seeding || ''}`;
                                        }
                                        
                                        row.innerHTML = `
                                            <td style="${cellStyle}; text-align: center;">${index + 1}</td>
                                            <td style="${cellStyle}">${player.name}</td>
                                            <td style="${cellStyle}">${seedCellHtml}</td>
                                        `;
                                        tbody.appendChild(row);
                                    });
                                    
                                    // Show clash summary if any clashes detected
                                    const clashes = detectAllSeedingClashes(playersWithRankings, seedRanges);
                                    if (clashes.length > 0) {
                                        showClashSummary(clashes);
                                    } else {
                                        // Hide clash summary if no clashes detected
                                        const clashSummary = document.getElementById('clashSummary');
                                        clashSummary.style.display = 'none';
                                    }
                                })
                                .catch(error => {
                                    console.error('Error fetching rankings:', error);
                                    // If rankings fetch fails, still show players without rankings
                                    tbody.innerHTML = '';
                                    data.players.forEach((player, index) => {
                                        const row = document.createElement('tr');
                                        const seedRangeClass = getSeedRangeClass(index + 1, seedRanges);
                                        row.className = seedRangeClass;
                                        row.innerHTML = `
                                            <td style="${cellStyle}; text-align: center;">${index + 1}</td>
                                            <td style="${cellStyle}">${player.name}</td>
                                            <td style="${cellStyle}">${player.seeding || ''}</td>
                                        `;
                                        tbody.appendChild(row);
                                    });

                                    // Detect and highlight seeding clashes
                                    const clashes = detectSeedingClashes(playersWithRankings, seedRanges);
                                    if (clashes.length > 0) {
                                        highlightClashes(clashes);
                                        showClashSummary(clashes);
                                    }
                                });
                        } else {
                            console.error('Failed to load players:', data.message);
                            tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px; color: red;">Error loading players</td></tr>';
                        }
                    })
                    .catch(error => {
                        console.error('Error loading players:', error);
                        tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px; color: red;">Error loading players</td></tr>';
                    });
            })
            .catch(error => {
                console.error('Error fetching seed ranges:', error);
                // If seed ranges fetch fails, show players without colors
                loadPlayersWithoutSeedRanges(category);
            });
    }

    // Fallback function to load players without seed range colors
    function loadPlayersWithoutSeedRanges(category) {
        const tbody = document.getElementById('clashTableBody');
        
        fetch(`/tournament/${tournamentId}/get_category_players/${category}?fields=full&t=${Date.now()}`)
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    fetch('/get_rankings')
                        .then(response => response.json())
                        .then(rankingsData => {
                            const playersWithRankings = data.players.map(player => ({
                                ...player,
                                ranking: getPlayerRanking(player.player_id, category, rankingsData),
                                originalSeed: player.seeding || ''
                            }));

                            playersWithRankings.sort((a, b) => {
                                const seedA = parseInt(a.seeding) || 999999;
                                const seedB = parseInt(b.seeding) || 999999;
                                return seedA - seedB;
                            });

                            tbody.innerHTML = '';
                            playersWithRankings.forEach((player, index) => {
                                const row = document.createElement('tr');
                                row.innerHTML = `
                                    <td style="${cellStyle}; text-align: center;">${index + 1}</td>
                                    <td style="${cellStyle}">${player.name}</td>
                                    <td style="${cellStyle}">${player.seeding || ''}</td>
                                `;
                                tbody.appendChild(row);
                            });
                        })
                        .catch(error => {
                            console.error('Error fetching rankings:', error);
                            tbody.innerHTML = '';
                            data.players.forEach((player, index) => {
                                const row = document.createElement('tr');
                                row.innerHTML = `
                                    <td style="${cellStyle}; text-align: center;">${index + 1}</td>
                                    <td style="${cellStyle}">${player.name}</td>
                                    <td style="${cellStyle}">${player.seeding || ''}</td>
                                `;
                                tbody.appendChild(row);
                            });
                        });
                } else {
                    console.error('Failed to load players:', data.message);
                    tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px; color: red;">Error loading players</td></tr>';
                }
            })
            .catch(error => {
                console.error('Error loading players:', error);
                tbody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px; color: red;">Error loading players</td></tr>';
            });
    }

    // Function to get seed range class based on S.No.
    function getSeedRangeClass(serialNumber, seedRanges) {
        const seedNumber = parseInt(serialNumber);
        
        console.log(`getSeedRangeClass called with serialNumber: ${serialNumber}, seedNumber: ${seedNumber}`);
        console.log('Available seed ranges:', seedRanges);
        
        // Find the matching seed range
        for (let i = 0; i < seedRanges.length; i++) {
            const range = seedRanges[i];
            if (seedNumber >= range.min && seedNumber <= range.max) {
                // Use the range index instead of description for CSS class
                const className = `seed-range-${i}`;
                console.log(`S.No. ${seedNumber} matches range ${range.min}-${range.max} (${range.description}) -> CSS class: ${className}`);
                return className;
            }
        }
        
        console.log(`S.No. ${seedNumber} - no matching range found, using default styling`);
        return ''; // Default styling if no range matches
    }

    // Function to get seed range class based on actual seed value (not S.No.)
    window.getSeedRangeClassBySeedValue = function(seedValue, seedRanges) {
        const seedNumber = parseInt(seedValue);
        
        console.log(`getSeedRangeClassBySeedValue called with seedValue: ${seedValue}, seedNumber: ${seedNumber}`);
        console.log('Available seed ranges:', seedRanges);
        
        // Find the matching seed range
        for (let i = 0; i < seedRanges.length; i++) {
            const range = seedRanges[i];
            if (seedNumber >= range.min && seedNumber <= range.max) {
                // Use the range index instead of description for CSS class
                const className = `seed-range-${i}`;
                console.log(`Seed ${seedNumber} matches range ${range.min}-${range.max} (${range.description}) -> CSS class: ${className}`);
                return className;
            }
        }
        
        console.log(`Seed ${seedNumber} - no matching range found, using default styling`);
        return ''; // Default styling if no range matches
    }

    // Function to detect seeding clashes
    function detectSeedingClash(player, players, index, seedRanges) {
        const seed = parseInt(player.seeding);
        const range = seedRanges.find(r => seed >= r.min && seed <= r.max);
        
        if (!range) {
            return { hasClash: false, suggestedSeeds: [] };
        }
        
        const rangeIndex = seedRanges.indexOf(range);
        const prevRange = seedRanges[rangeIndex - 1];
        const nextRange = seedRanges[rangeIndex + 1];
        
        const prevRangePlayers = players.filter(p => {
            const pSeed = parseInt(p.seeding);
            return prevRange && pSeed >= prevRange.min && pSeed <= prevRange.max;
        });
        
        const nextRangePlayers = players.filter(p => {
            const pSeed = parseInt(p.seeding);
            return nextRange && pSeed >= nextRange.min && pSeed <= nextRange.max;
        });
        
        const hasClash = prevRangePlayers.some(p => p.seeding === player.seeding) &&
                         nextRangePlayers.some(p => p.seeding === player.seeding);
        
        let suggestedSeeds = [];
        if (hasClash) {
            const suggestedSeed = seed + 1;
            suggestedSeeds = [suggestedSeed];
            
            // Check if the suggested seed is already taken
            const isSuggestedSeedTaken = players.some(p => parseInt(p.seeding) === suggestedSeed);
            if (isSuggestedSeedTaken) {
                // Find the next available seed
                let nextAvailableSeed = suggestedSeed + 1;
                while (players.some(p => parseInt(p.seeding) === nextAvailableSeed)) {
                    nextAvailableSeed++;
                }
                suggestedSeeds.push(nextAvailableSeed);
            }
        }
        
        return { hasClash, suggestedSeeds };
    }

    // Function to detect all seeding clashes
    function detectAllSeedingClashes(players, seedRanges) {
        const clashes = [];
        players.forEach((player, index) => {
            const clashInfo = detectSeedingClash(player, players, index, seedRanges);
            if (clashInfo.hasClash) {
                clashes.push({
                    player: player,
                    suggestedSeeds: clashInfo.suggestedSeeds
                });
            }
        });
        return clashes;
    }

    // Function to show clash summary
    function showClashSummary(clashes) {
        const clashSummary = document.getElementById('clashSummary');
        const clashItems = document.getElementById('clashItems');
        
        clashItems.innerHTML = '';
        
        // Add overall clash resolution options
        const overallResolutionDiv = document.createElement('div');
        overallResolutionDiv.className = 'clash-item';
        overallResolutionDiv.style.backgroundColor = '#e8f5e8';
        overallResolutionDiv.innerHTML = `
            <div style="margin-bottom: 15px;">
                <strong style="color: #2e7d32;">🎯 Overall Clash Resolution Options:</strong>
            </div>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="resolve-clash-btn" style="background-color: #2196f3;" onclick="autoResolveAllClashes()">
                    🔄 Auto-Resolve All Clashes
                </button>
                <button class="resolve-clash-btn" style="background-color: #ff9800;" onclick="shuffleClashPlayers()">
                    🎲 Shuffle Clash Players
                </button>
                <button class="resolve-clash-btn" style="background-color: #9c27b0;" onclick="showPaperChitResolution()">
                    📄 Paper Chit Resolution
                </button>
            </div>
        `;
        clashItems.appendChild(overallResolutionDiv);
        
        clashes.forEach((clash, idx) => {
            const clashItem = document.createElement('div');
            clashItem.className = 'clash-item';
            
            const playerNames = clash.players.map(p => p.player.name).join(', ');
            const ranges = clash.ranges.join(' and ');
            
            let shuffleBtnHtml = '';
            if (window.clashResolutionMode === 'auto') {
                shuffleBtnHtml = `<button class="resolve-clash-btn" style="background-color: #ff9800; margin-left: 10px;" onclick="shuffleClashGroup(${idx})" title="Shuffle this group">🔀 Shuffle</button>`;
            }
            
            clashItem.innerHTML = `
                <div>
                    <strong>Seed ${clash.seed}</strong> is used by <strong>${playerNames}</strong> 
                    across different ranges: <strong>${ranges}</strong>
                    ${shuffleBtnHtml}
                </div>
                <div style="margin-top: 8px;">
                    <strong>Individual Resolution:</strong> 
                    ${clash.suggestedSeeds.map(seed => 
                        `<button class="resolve-clash-btn" onclick="resolveClash('${clash.seed}', ${seed})">Use Seed ${seed}</button>`
                    ).join(' ')}
                </div>
            `;
            
            clashItems.appendChild(clashItem);
        });
        
        clashSummary.style.display = 'block';
    }

    // Shuffle function for a single clash group
    function shuffleClashGroup(clashIdx) {
        if (!window.currentClashes || !window.currentClashes[clashIdx]) return;
        const clash = window.currentClashes[clashIdx];
        // Get all valid values for this group
        const validPlayerIndices = clash.players.map(p => p.index);
        const validRange = clash.players.map(p => p.range);
        // Get min/max from the first player's range (all should be same for group)
        const min = Math.min(...validRange.map(r => r.min));
        const max = Math.max(...validRange.map(r => r.max));
        const possibleSeeds = [];
        for (let v = min; v <= max; v++) possibleSeeds.push(v);
        // Shuffle possibleSeeds and assign
        for (let i = possibleSeeds.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [possibleSeeds[i], possibleSeeds[j]] = [possibleSeeds[j], possibleSeeds[i]];
        }
        // Assign to each player in the group
        const tbody = document.getElementById('clashTableBody');
        validPlayerIndices.forEach((rowIdx, i) => {
            const row = tbody.rows[rowIdx];
            if (row) {
                const seedCell = row.cells[2];
                const select = seedCell.querySelector('select');
                if (select) {
                    select.value = possibleSeeds[i];
                }
            }
        });
        sortTableBySeed();
    }

    // Function to detect seeding clashes across range boundaries
    function detectSeedingClashes(players, seedRanges) {
        const clashes = [];
        const seedGroups = {};
        
        // Group players by seed value
        players.forEach((player, index) => {
            const seed = player.seeding;
            if (seed && seed !== '') {
                if (!seedGroups[seed]) {
                    seedGroups[seed] = [];
                }
                seedGroups[seed].push({
                    player: player,
                    index: index,
                    range: getSeedRangeForSNo(index + 1, seedRanges)
                });
            }
        });
        
        // Check for clashes (same seed across different unique min-max ranges)
        Object.keys(seedGroups).forEach(seed => {
            const playersWithSeed = seedGroups[seed];
            if (playersWithSeed.length > 1) {
                // Use min-max as unique range identifier
                const rangeIdentifiers = playersWithSeed.map(p => {
                    const range = p.range;
                    return range ? `${range.min}-${range.max}` : 'unknown';
                });
                const uniqueRanges = [...new Set(rangeIdentifiers)];
                if (uniqueRanges.length > 1) {
                    // This is a clash - same seed across different unique ranges
                    const rangeDescriptions = uniqueRanges.map(rangeId => {
                        const [min, max] = rangeId.split('-').map(Number);
                        const range = seedRanges.find(r => r.min === min && r.max === max);
                        return range ? `${range.description} (${min}-${max})` : rangeId;
                    });
                    
                    clashes.push({
                        seed: seed,
                        players: playersWithSeed,
                        ranges: rangeDescriptions,
                        rangeIdentifiers: uniqueRanges,
                        suggestedSeeds: generateSuggestedSeeds(seed, players)
                    });
                }
            }
        });
        
        console.log('Detected clashes:', clashes);
        return clashes;
    }

    // Function to get seed range for a specific S.No.
    function getSeedRangeForSNo(serialNumber, seedRanges) {
        const seedNumber = parseInt(serialNumber);
        for (const range of seedRanges) {
            if (seedNumber >= range.min && seedNumber <= range.max) {
                return range;
            }
        }
        return null;
    }

    // Function to generate suggested seeds for resolving clashes
    function generateSuggestedSeeds(clashSeed, allPlayers) {
        const usedSeeds = new Set(allPlayers.map(p => parseInt(p.seeding)).filter(s => !isNaN(s)));
        const clashSeedNum = parseInt(clashSeed);
        const suggestions = [];
        
        // Try next available seeds
        for (let i = 1; i <= 10; i++) {
            const suggestedSeed = clashSeedNum + i;
            if (!usedSeeds.has(suggestedSeed)) {
                suggestions.push(suggestedSeed);
                if (suggestions.length >= 3) break; // Limit to 3 suggestions
            }
        }
        
        // If we don't have enough suggestions, try lower seeds
        if (suggestions.length < 3) {
            for (let i = 1; i <= 10; i++) {
                const suggestedSeed = clashSeedNum - i;
                if (suggestedSeed > 0 && !usedSeeds.has(suggestedSeed)) {
                    suggestions.unshift(suggestedSeed);
                    if (suggestions.length >= 3) break;
                }
            }
        }
        
        return suggestions;
    }

    // Function to highlight clashes in the table
    function highlightClashes(clashes) {
        const tbody = document.getElementById('clashTableBody');
        const rows = tbody.getElementsByTagName('tr');
        
        clashes.forEach(clash => {
            clash.players.forEach(playerInfo => {
                const row = rows[playerInfo.index];
                if (row) {
                    row.classList.add('seeding-clash');
                    // Add tooltip with clash information
                    row.title = `Seeding clash detected! Seed ${clash.seed} appears in multiple ranges: ${clash.ranges.join(', ')}`;
                }
            });
        });
    }

    // Function to resolve a clash by updating seed values
    function resolveClash(oldSeed, newSeed) {
        const tbody = document.getElementById('clashTableBody');
        const rows = tbody.getElementsByTagName('tr');
        
        // Find all rows with the old seed and update them
        for (let i = 0; i < rows.length; i++) {
            const row = rows[i];
            const seedCell = row.cells[2]; // Seed column
            if (seedCell.textContent.trim() === oldSeed) {
                seedCell.textContent = newSeed;
                row.classList.remove('seeding-clash');
                row.title = '';
            }
        }
        
        // Trigger animation by sorting the table after seed change
        setTimeout(() => {
            sortTableBySeedClash();
        }, 100);
        
        // Re-detect clashes after resolution
        const category = document.getElementById('clashCategorySelect').value;
        if (category) {
            // Don't reload immediately to allow animation to complete
            setTimeout(() => {
                loadClashPlayers(); // Reload to re-detect clashes
            }, 2000); // Wait for animation to complete
        }
    }

    // Add this to your existing script section
    document.addEventListener('DOMContentLoaded', function() {
        const categorySelect = document.getElementById('categorySelect');
        const generateBracketBtn = document.getElementById('generateBracket');
        const bracketContainer = document.getElementById('bracket');

        categorySelect.addEventListener('change', function() {
            generateBracketBtn.disabled = !this.value;
        });

        generateBracketBtn.addEventListener('click', async function() {
            const category = categorySelect.value;
            if (!category) return;

            try {
                const response = await fetch(`/tournament/{{ tournament['Tournament Id'] }}/get_category_players/${category}`);
                const data = await response.json();
                
                if (data.error) {
                    alert(data.error);
                    return;
                }

                generateBracket(data.players);
            } catch (error) {
                console.error('Error:', error);
                alert('Error loading players');
            }
        });

        // Store bracket data globally for use in swapping
        let bracketData = {
            currentRounds: [],
            allPlayers: [],
            selectedRound: -1,
            selectedMatch: -1,
            selectedPlayerIndex: -1,
            selectedPlayer: null,
            targetPlayer: null
        };
        
        function generateBracket(players) {
            // Store all players for reference
            bracketData.allPlayers = players;
            
            // Sort players by seeding (ascending order - seed 1 is best)
            players.sort((a, b) => {
                const seedA = parseInt(a.seeding) || 999999;
                const seedB = parseInt(b.seeding) || 999999;
                return seedA - seedB;
            });

            // Pad with BYEs
            const numPlayers = players.length;
            const nextPowerOf2 = Math.pow(2, Math.ceil(Math.log2(numPlayers)));
            const numByes = nextPowerOf2 - numPlayers;
            const paddedPlayers = [...players];
            for (let i = 0; i < numByes; i++) {
                paddedPlayers.push({ name: 'BYE', seeding: 'BYE' });
            }

            // Generate proper seeding order for tournament bracket
            const seededPlayers = generateSeededBracketOrder(paddedPlayers, nextPowerOf2);

            // Generate first round matches
            const firstRoundMatches = [];
            for (let i = 0; i < seededPlayers.length; i += 2) {
                firstRoundMatches.push([seededPlayers[i], seededPlayers[i + 1]]);
            }

            // Calculate total number of rounds
            const totalRounds = Math.log2(nextPowerOf2);

            // Generate all rounds
            const rounds = [firstRoundMatches];
            let currentRound = firstRoundMatches;

            // Generate subsequent rounds, handling BYEs
            for (let round = 1; round < totalRounds; round++) {
                const nextRound = [];
                for (let i = 0; i < currentRound.length; i += 2) {
                    let player1, player2;

                    // Determine winner of match1
                    const match1 = currentRound[i];
                    if (match1[0].name === 'BYE') player1 = match1[1];
                    else if (match1[1].name === 'BYE') player1 = match1[0];
                    else player1 = { name: `Winner of Match ${i + 1}`, seeding: '' };

                    // Determine winner of match2
                    const match2 = currentRound[i + 1];
                    if (match2[0].name === 'BYE') player2 = match2[1];
                    else if (match2[1].name === 'BYE') player2 = match2[0];
                    else player2 = { name: `Winner of Match ${i + 2}`, seeding: '' };

                    nextRound.push([player1, player2]);
                }
                rounds.push(nextRound);
                currentRound = nextRound;
            }

            // Render bracket
            bracketContainer.innerHTML = '';
            let globalMatchCounter = 1; // Global counter for sequential match numbering
            rounds.forEach((round, roundIndex) => {
                const roundDiv = document.createElement('div');
                roundDiv.className = 'round';
                
                const roundTitle = document.createElement('div');
                roundTitle.className = 'round-title';
                roundTitle.textContent = getRoundLabel(roundIndex, rounds.length);
                roundDiv.appendChild(roundTitle);

                // Calculate spacing for proper alignment
                const totalMatches = round.length;
                const isFirstRound = roundIndex === 0;
                const isLastRound = roundIndex === rounds.length - 1;

                round.forEach((match, matchIndex) => {
                    const matchDiv = document.createElement('div');
                    matchDiv.className = 'match';
                    matchDiv.id = `round-${roundIndex + 1}-match-${matchIndex + 1}`;
                    
                    // Add specific styling for different rounds
                    if (isFirstRound) {
                        matchDiv.style.marginBottom = '20px';
                    } else {
                        matchDiv.style.marginBottom = '40px';
                    }
                    
                    // Add players to match (original 2-player layout)
                    match.forEach((player, playerIndex) => {
                        const playerDiv = document.createElement('div');
                        playerDiv.className = `player ${player.name === 'BYE' ? 'bye' : ''}`;
                        playerDiv.style.cssText = `
                            padding: 4px 8px;
                            margin: 2px 0;
                            border-radius: 4px;
                            background: ${player.name === 'BYE' ? '#f0f0f0' : '#f8f9fa'};
                            border: 1px solid ${player.name === 'BYE' ? '#ddd' : '#e9ecef'};
                            cursor: ${player.name !== 'BYE' && !player.name.startsWith('Winner of Match') ? 'pointer' : 'default'};
                            transition: all 0.2s ease;
                        `;
                        
                        const nameSpan = document.createElement('span');
                        nameSpan.textContent = player.name;
                        nameSpan.style.cssText = `
                            font-weight: 500;
                            color: ${player.name === 'BYE' ? '#666' : '#1e3c72'};
                        `;
                        
                        if (player.name !== 'BYE' && !player.name.startsWith('Winner of Match')) {
                            nameSpan.addEventListener('click', function(e) {
                                e.stopPropagation();
                                showSwapPopup(roundIndex, matchIndex, playerIndex, player);
                            });
                            
                            playerDiv.addEventListener('mouseenter', function() {
                                this.style.background = '#e3f2fd';
                                this.style.borderColor = '#1e3c72';
                            });
                            
                            playerDiv.addEventListener('mouseleave', function() {
                                this.style.background = '#f8f9fa';
                                this.style.borderColor = '#e9ecef';
                            });
                        }
                        
                        playerDiv.appendChild(nameSpan);
                        
                        if (player.seeding && player.seeding !== 'BYE') {
                            const seedSpan = document.createElement('span');
                            seedSpan.className = 'seed';
                            seedSpan.textContent = `(${player.seeding})`;
                            seedSpan.style.cssText = `
                                margin-left: 8px;
                                color: #666;
                                font-size: 0.9em;
                                font-weight: 400;
                            `;
                            playerDiv.appendChild(seedSpan);
                        }
                        
                        matchDiv.appendChild(playerDiv);
                    });
                    
                    // Only add arrow for non-final rounds and non-disabled matches
                    if (!isLastRound) {
                        // Check if this match should be disabled
                        const shouldDisableMatch = checkIfMatchShouldBeDisabled(match, roundIndex, matchIndex);
                        
                        // Also check after a short delay to ensure DOM is ready
                        let delayedDisable = false;
                        setTimeout(() => {
                            const matchElement = document.getElementById(`round-${roundIndex + 1}-match-${matchIndex + 1}`);
                            if (matchElement) {
                                const matchText = matchElement.textContent.toLowerCase();
                                if (matchText.includes('bye') || 
                                    matchText.includes('winner of match') || 
                                    matchText.includes('tbd') || 
                                    matchText.includes('to be determined')) {
                                    console.log('Delayed check: Match should be disabled');
                                    delayedDisable = true;
                                    // Remove the arrow if it was already added
                                    const existingArrow = matchDiv.querySelector('.match-arrow');
                                    if (existingArrow) {
                                        existingArrow.remove();
                                    }
                                }
                            }
                        }, 100);
                        
                        // Only create arrow if match is not disabled
                        if (!shouldDisableMatch) {
                            const arrowDiv = document.createElement('div');
                            arrowDiv.className = 'match-arrow';
                            
                            arrowDiv.addEventListener('click', function(e) {
                                e.stopPropagation();
                                
                                // Get actual player names from the match element
                                let player1Name = 'Player 1';
                                let player2Name = 'Player 2';
                                
                                const playerDivs = matchDiv.querySelectorAll('.player');
                                if (playerDivs.length >= 2) {
                                    const player1Text = playerDivs[0].textContent.trim();
                                    player1Name = player1Text.replace(/\(\d+\)$/, '').replace(/\(\d+-\d+\)$/, '').trim();
                                    
                                    const player2Text = playerDivs[1].textContent.trim();
                                    player2Name = player2Text.replace(/\(\d+\)$/, '').replace(/\(\d+-\d+\)$/, '').trim();
                                }
                                
                                // Create match data for the modal
                                const matchData = {
                                    matchId: matchDiv.id,
                                    player1: player1Name,
                                    player2: player2Name,
                                    scores: match.scores || null
                                };
                                openMatchResultsModal(matchData);
                            });
                            
                            matchDiv.appendChild(arrowDiv);
                        }
                    }
                    

                    // Add match number above the match (skip for BYE matches)
                    const hasBye = match.some(player => player.name === 'BYE');
                    if (!hasBye) {
                        const matchInfoDiv = document.createElement('div');
                        matchInfoDiv.className = 'match-info-above';
                        matchInfoDiv.textContent = `M${globalMatchCounter}`;
                        roundDiv.appendChild(matchInfoDiv);
                        globalMatchCounter++; // Increment for next match
                    }
                    
                    roundDiv.appendChild(matchDiv);
                });

                bracketContainer.appendChild(roundDiv);
            });
            
            bracketData.currentRounds = rounds;
            
            // Apply sequential alignment - align each round one by one
            setTimeout(() => {
                alignBracketRoundsSequential();
            }, 300);
        }


        function alignBracketRoundsSequential() {
            const rounds = document.querySelectorAll('.round');
            if (rounds.length < 2) return;
            
            console.log('Starting sequential alignment...');
            
            // Align each round sequentially with proper delays
            for (let roundIndex = 1; roundIndex < rounds.length; roundIndex++) {
                setTimeout(() => {
                    alignSingleRound(roundIndex);
                }, roundIndex * 200); // 200ms delay between each round
            }
        }
        
        function alignSingleRound(roundIndex) {
            const rounds = document.querySelectorAll('.round');
            if (roundIndex >= rounds.length) return;
            
            const currentRound = rounds[roundIndex];
            const previousRound = rounds[roundIndex - 1];
            const currentMatches = currentRound.querySelectorAll('.match');
            const previousMatches = previousRound.querySelectorAll('.match');
            
            console.log(`Aligning Round ${roundIndex + 1} with ${currentMatches.length} matches...`);
            
            currentMatches.forEach((currentMatch, matchIndex) => {
                // Calculate which parent matches this current match should be centered between
                const parentMatch1Index = matchIndex * 2;
                const parentMatch2Index = parentMatch1Index + 1;
                
                if (parentMatch1Index < previousMatches.length && parentMatch2Index < previousMatches.length) {
                    const parentMatch1 = previousMatches[parentMatch1Index];
                    const parentMatch2 = previousMatches[parentMatch2Index];
                    
                    // Get positions using getBoundingClientRect for accuracy
                    const parent1Rect = parentMatch1.getBoundingClientRect();
                    const parent2Rect = parentMatch2.getBoundingClientRect();
                    const currentRect = currentMatch.getBoundingClientRect();
                    
                    // Calculate the center between the two parent matches
                    const parent1Center = parent1Rect.top + parent1Rect.height / 2;
                    const parent2Center = parent2Rect.top + parent2Rect.height / 2;
                    const targetCenter = (parent1Center + parent2Center) / 2;
                    
                    // Get current match position
                    const currentMatchCenter = currentRect.top + currentRect.height / 2;
                    
                    // Calculate the offset needed
                    const offset = targetCenter - currentMatchCenter;
                    
                    console.log(`Round ${roundIndex + 1}, Match ${matchIndex + 1}: Target: ${targetCenter}, Current: ${currentMatchCenter}, Offset: ${offset}`);
                    
                    // Apply the offset
                    if (Math.abs(offset) > 2) {
                        currentMatch.style.transform = `translateY(${offset}px)`;
                        currentMatch.style.transition = 'transform 0.3s ease';
                        
                        // Also move the match number if it exists
                        const matchNumber = currentMatch.previousElementSibling;
                        if (matchNumber && matchNumber.classList.contains('match-info-above')) {
                            matchNumber.style.transform = `translateY(${offset}px)`;
                            matchNumber.style.transition = 'transform 0.3s ease';
                        }
                    }
                    
                    // Draw connecting lines after positioning
                    setTimeout(() => {
                        drawConnectingLines(parentMatch1, parentMatch2, currentMatch);
                    }, 100);
                }
            });
        }
        
        function drawConnectingLines(parentMatch1, parentMatch2, childMatch) {
            // Remove any existing lines for this connection
            const existingLines = document.querySelectorAll(`[data-connection="${parentMatch1.id}-${parentMatch2.id}-${childMatch.id}"]`);
            existingLines.forEach(line => line.remove());
            
            // Get positions after any transforms
            const parent1Rect = parentMatch1.getBoundingClientRect();
            const parent2Rect = parentMatch2.getBoundingClientRect();
            const childRect = childMatch.getBoundingClientRect();
            const bracketRect = document.querySelector('.bracket').getBoundingClientRect();
            
            // Calculate relative positions within the bracket
            const parent1X = parent1Rect.right - bracketRect.left;
            const parent1Y = parent1Rect.top + parent1Rect.height / 2 - bracketRect.top;
            const parent2X = parent2Rect.right - bracketRect.left;
            const parent2Y = parent2Rect.top + parent2Rect.height / 2 - bracketRect.top;
            const childX = childRect.left - bracketRect.left;
            const childY = childRect.top + childRect.height / 2 - bracketRect.top;
            
            // Create horizontal lines from parent matches
            const line1 = document.createElement('div');
            line1.className = 'connecting-line horizontal-line';
            line1.style.left = `${parent1X}px`;
            line1.style.top = `${parent1Y}px`;
            line1.style.width = `${childX - parent1X}px`;
            line1.setAttribute('data-connection', `${parentMatch1.id}-${parentMatch2.id}-${childMatch.id}`);
            
            const line2 = document.createElement('div');
            line2.className = 'connecting-line horizontal-line';
            line2.style.left = `${parent2X}px`;
            line2.style.top = `${parent2Y}px`;
            line2.style.width = `${childX - parent2X}px`;
            line2.setAttribute('data-connection', `${parentMatch1.id}-${parentMatch2.id}-${childMatch.id}`);
            
            // Create vertical line connecting the horizontal lines
            const verticalLine = document.createElement('div');
            verticalLine.className = 'connecting-line vertical-line';
            verticalLine.style.left = `${childX}px`;
            verticalLine.style.top = `${Math.min(parent1Y, parent2Y)}px`;
            verticalLine.style.height = `${Math.abs(parent2Y - parent1Y)}px`;
            verticalLine.setAttribute('data-connection', `${parentMatch1.id}-${parentMatch2.id}-${childMatch.id}`);
            
            // Add lines to bracket
            document.querySelector('.bracket').appendChild(line1);
            document.querySelector('.bracket').appendChild(line2);
            document.querySelector('.bracket').appendChild(verticalLine);
        }
        
        // Function to check if a match should be disabled
        function checkIfMatchShouldBeDisabled(match, roundIndex, matchIndex) {
            console.log('Checking match for disable - Match data:', match);
            console.log('Match type:', typeof match, 'Is array:', Array.isArray(match));
            
            if (Array.isArray(match)) {
                console.log('Match array length:', match.length);
                match.forEach((player, index) => {
                    console.log(`Player ${index}:`, player, 'Type:', typeof player);
                    if (typeof player === 'object' && player) {
                        console.log(`Player ${index} object keys:`, Object.keys(player));
                        console.log(`Player ${index} Name:`, player.Name);
                    }
                });
                
                // Check if any player is BYE
                const hasBYE = match.some(player => {
                    const isBYE = player === 'BYE' || 
                                 player === null || 
                                 player === undefined ||
                                 (typeof player === 'object' && player && player.Name === 'BYE');
                    console.log('Checking player for BYE:', player, 'Is BYE:', isBYE);
                    return isBYE;
                });
                
                if (hasBYE) {
                    console.log('Match disabled: Contains BYE');
                    return true;
                }
                
                // Check if any player name contains "Winner of Match"
                if (match.some(player => {
                    const playerName = typeof player === 'string' ? player : 
                                     (typeof player === 'object' && player && player.Name) ? player.Name : '';
                    return playerName.toLowerCase().includes('winner of match');
                })) {
                    console.log('Match disabled: Contains Winner of Match');
                    return true;
                }
                
                // Check if any player name contains "TBD" or "To Be Determined"
                if (match.some(player => {
                    const playerName = typeof player === 'string' ? player : 
                                     (typeof player === 'object' && player && player.Name) ? player.Name : '';
                    return playerName.toLowerCase().includes('tbd') || 
                           playerName.toLowerCase().includes('to be determined');
                })) {
                    console.log('Match disabled: Contains TBD');
                    return true;
                }
            }
            
            // Also check the match element's text content as fallback
            const matchElement = document.getElementById(`round-${roundIndex + 1}-match-${matchIndex + 1}`);
            if (matchElement) {
                const matchText = matchElement.textContent.toLowerCase();
                console.log('Match element text content:', matchText);
                
                if (matchText.includes('bye') || 
                    matchText.includes('winner of match') || 
                    matchText.includes('tbd') || 
                    matchText.includes('to be determined')) {
                    console.log('Match disabled: Text content contains disabled keywords');
                    return true;
                }
            } else {
                console.log('Match element not found:', `round-${roundIndex + 1}-match-${matchIndex + 1}`);
            }
            
            // Additional check: look for any element with BYE text in the match
            const matchElementByClass = document.querySelector(`#round-${roundIndex + 1}-match-${matchIndex + 1}`);
            if (matchElementByClass) {
                const byeElements = matchElementByClass.querySelectorAll('*');
                for (let element of byeElements) {
                    if (element.textContent && element.textContent.toLowerCase().includes('bye')) {
                        console.log('Match disabled: Found BYE in child element:', element.textContent);
                        return true;
                    }
                }
            }
            
            return false;
        }
        
        // Match Results Modal Functions
        let currentMatchData = null;
        
        function openMatchResultsModal(matchData) {
            currentMatchData = matchData;
            const modal = document.getElementById('matchResultsModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalContent = document.getElementById('modalContent');
            
            // Get actual player names from the match element
            const matchElement = document.getElementById(matchData.matchId);
            let player1Name = 'Player 1';
            let player2Name = 'Player 2';
            
            if (matchElement) {
                // Try to find player divs with different selectors
                const playerDivs = matchElement.querySelectorAll('.player');
                if (playerDivs.length >= 2) {
                    // Get first player name
                    const player1Text = playerDivs[0].textContent.trim();
                    player1Name = player1Text.replace(/\(\d+\)$/, '').replace(/\(\d+-\d+\)$/, '').trim();
                    
                    // Get second player name
                    const player2Text = playerDivs[1].textContent.trim();
                    player2Name = player2Text.replace(/\(\d+\)$/, '').replace(/\(\d+-\d+\)$/, '').trim();
                } else {
                    // Fallback: try to get names from any text content
                    const allText = matchElement.textContent;
                    const lines = allText.split('\n').filter(line => line.trim());
                    if (lines.length >= 2) {
                        player1Name = lines[0].replace(/\(\d+\)$/, '').replace(/\(\d+-\d+\)$/, '').trim();
                        player2Name = lines[1].replace(/\(\d+\)$/, '').replace(/\(\d+-\d+\)$/, '').trim();
                    }
                }
                
                console.log('Extracted player names:', player1Name, player2Name);
            }
            
            // Update match data with actual names
            currentMatchData.player1 = player1Name;
            currentMatchData.player2 = player2Name;
            
            // Set modal title
            modalTitle.textContent = `Update Results - ${player1Name} vs ${player2Name}`;
            
            // Generate results table
            const resultsTable = generateResultsTable(currentMatchData);
            modalContent.innerHTML = resultsTable;
            
            // Add event listeners
            setupModalEventListeners();
            
            // Show modal
            modal.style.display = 'block';
        }
        
        function setupModalEventListeners() {
            // Close button
            const closeBtn = document.getElementById('modalClose');
            if (closeBtn) {
                closeBtn.onclick = closeMatchResultsModal;
            }
            
            // Cancel button
            const cancelBtn = document.getElementById('modalCancel');
            if (cancelBtn) {
                cancelBtn.onclick = closeMatchResultsModal;
            }
            
            // Save button
            const saveBtn = document.getElementById('modalSave');
            if (saveBtn) {
                saveBtn.onclick = saveMatchResults;
            }
        }
        
        function closeMatchResultsModal() {
            const modal = document.getElementById('matchResultsModal');
            modal.style.display = 'none';
            currentMatchData = null;
        }
        
        function generateResultsTable(matchData) {
            const maxSets = 5; // Maximum number of sets to display
            
            let tableHTML = `
                <table class="results-table">
                    <thead>
                        <tr>
                            <th>Player</th>
            `;
            
            // Add set columns
            for (let i = 1; i <= maxSets; i++) {
                tableHTML += `<th>Set ${i}</th>`;
            }
            
            tableHTML += `
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td class="player-name">${matchData.player1}</td>
            `;
            
            // Add score inputs for player 1
            for (let i = 1; i <= maxSets; i++) {
                const existingScore = matchData.scores && matchData.scores.player1 && matchData.scores.player1[i-1] ? matchData.scores.player1[i-1] : '';
                // Tab order: Set1 P1 (1), Set1 P2 (2), Set2 P1 (3), Set2 P2 (4), etc.
                const tabIndex = (i - 1) * 2 + 1;
                tableHTML += `<td><input type="number" class="score-input" id="p1_set${i}" value="${existingScore}" min="0" max="99" tabindex="${tabIndex}"></td>`;
            }
            
            tableHTML += `
                        </tr>
                        <tr>
                            <td class="player-name">${matchData.player2}</td>
            `;
            
            // Add score inputs for player 2
            for (let i = 1; i <= maxSets; i++) {
                const existingScore = matchData.scores && matchData.scores.player2 && matchData.scores.player2[i-1] ? matchData.scores.player2[i-1] : '';
                // Tab order: Set1 P1 (1), Set1 P2 (2), Set2 P1 (3), Set2 P2 (4), etc.
                const tabIndex = (i - 1) * 2 + 2;
                tableHTML += `<td><input type="number" class="score-input" id="p2_set${i}" value="${existingScore}" min="0" max="99" tabindex="${tabIndex}"></td>`;
            }
            
            tableHTML += `
                        </tr>
                    </tbody>
                </table>
            `;
            
            return tableHTML;
        }
        
        function saveMatchResults() {
            if (!currentMatchData) return;
            
            // Collect scores
            const scores = {
                player1: [],
                player2: []
            };
            
            for (let i = 1; i <= 5; i++) {
                const p1Score = document.getElementById(`p1_set${i}`).value;
                const p2Score = document.getElementById(`p2_set${i}`).value;
                
                scores.player1.push(p1Score || '');
                scores.player2.push(p2Score || '');
            }
            
            // Calculate winner and format scores
            const matchResult = calculateMatchResult(scores);
            
            // Update match data
            currentMatchData.scores = scores;
            currentMatchData.winner = matchResult.winner;
            currentMatchData.displayScores = matchResult.displayScores;
            
            // Update the match display in the bracket
            updateMatchDisplay(currentMatchData);
            
            // Close modal
            closeMatchResultsModal();
        }
        
        function calculateMatchResult(scores) {
            let player1SetsWon = 0;
            let player2SetsWon = 0;
            const displayScores = [];
            
            // Count sets won by each player
            for (let i = 0; i < 5; i++) {
                const p1Score = parseInt(scores.player1[i]) || 0;
                const p2Score = parseInt(scores.player2[i]) || 0;
                
                if (p1Score > 0 || p2Score > 0) { // Only count sets that have scores
                    if (p1Score > p2Score) {
                        player1SetsWon++;
                        displayScores.push(`${p1Score}-${p2Score}`);
                    } else if (p2Score > p1Score) {
                        player2SetsWon++;
                        displayScores.push(`${p1Score}-${p2Score}`);
                    }
                }
            }
            
            // Determine winner
            let winner;
            if (player1SetsWon > player2SetsWon) {
                winner = currentMatchData.player1;
            } else if (player2SetsWon > player1SetsWon) {
                winner = currentMatchData.player2;
            } else {
                winner = 'Tie'; // Handle tie situation
            }
            
            return {
                winner: winner,
                displayScores: displayScores.join(', '),
                player1SetsWon: player1SetsWon,
                player2SetsWon: player2SetsWon
            };
        }
        
        function updateMatchDisplay(matchData) {
            console.log('Updating match display for:', matchData);
            
            // Find the match element in the bracket and update its display
            const matchElement = document.getElementById(matchData.matchId);
            console.log('Match element found:', matchElement);
            
            if (matchElement) {
                // Update the match display with results
                const playerDivs = matchElement.querySelectorAll('.player');
                console.log('Player divs found:', playerDivs.length);
                
                if (playerDivs.length >= 2) {
                    const player1Div = playerDivs[0];
                    const player2Div = playerDivs[1];
                    
                    console.log('Player 1 div:', player1Div);
                    console.log('Player 2 div:', player2Div);
                    
                    // Show winner with simple tick
                    if (matchData.winner) {
                        console.log('Winner:', matchData.winner);
                        
                        const isPlayer1Winner = matchData.winner === matchData.player1;
                        const isPlayer2Winner = matchData.winner === matchData.player2;
                        
                        // Update player 1 display - just add tick if winner
                        if (isPlayer1Winner) {
                            player1Div.innerHTML = `${matchData.player1} <span style="color: #28a745; font-weight: bold; margin-left: 5px;">✓</span>`;
                        } else {
                            player1Div.innerHTML = matchData.player1;
                        }
                        
                        // Update player 2 display - just add tick if winner
                        if (isPlayer2Winner) {
                            player2Div.innerHTML = `${matchData.player2} <span style="color: #28a745; font-weight: bold; margin-left: 5px;">✓</span>`;
                        } else {
                            player2Div.innerHTML = matchData.player2;
                        }
                        
                        console.log('Updated player displays with simple ticks');
                    } else {
                        console.log('No winner found');
                    }
                } else {
                    console.log('Not enough player divs found');
                }
                
                // Update the match data for progression to next round
                updateMatchProgression(matchData);
            } else {
                console.log('Match element not found:', matchData.matchId);
            }
        }
        
        function updateMatchProgression(matchData) {
            console.log(`Winner of ${matchData.matchId}: ${matchData.winner}`);
            
            // Extract round and match numbers from matchId (e.g., "round-2-match-1")
            const matchIdParts = matchData.matchId.split('-');
            const currentRound = parseInt(matchIdParts[1]);
            const currentMatch = parseInt(matchIdParts[3]);
            
            console.log('Current round:', currentRound, 'Current match:', currentMatch);
            
            // Calculate next round and match
            const nextRound = currentRound + 1;
            const nextMatch = Math.ceil(currentMatch / 2);
            const nextMatchId = `round-${nextRound}-match-${nextMatch}`;
            
            console.log('Next round:', nextRound, 'Next match:', nextMatch, 'Next match ID:', nextMatchId);
            
            // Find the next round match element
            const nextMatchElement = document.getElementById(nextMatchId);
            if (nextMatchElement) {
                console.log('Next match element found:', nextMatchElement);
                
                // Determine which position in the next match this winner should fill
                const isFirstPosition = (currentMatch % 2 === 1);
                const targetPlayerIndex = isFirstPosition ? 0 : 1;
                
                console.log('Is first position:', isFirstPosition, 'Target player index:', targetPlayerIndex);
                
                // Update the next match with the winner
                const nextMatchPlayerDivs = nextMatchElement.querySelectorAll('.player');
                if (nextMatchPlayerDivs[targetPlayerIndex]) {
                    const winnerName = matchData.winner;
                    // Use the same styling as original players - just plain text
                    nextMatchPlayerDivs[targetPlayerIndex].innerHTML = winnerName;
                    
                    console.log(`Updated next match position ${targetPlayerIndex} with winner: ${winnerName}`);
                    
                    // Update the bracket data to reflect the progression
                    updateBracketData(currentRound, currentMatch, nextRound, nextMatch, winnerName);
                    
                    // Check if both players are now known and add arrow if ready
                    checkAndAddArrowToNextMatch(nextMatchElement, nextRound, nextMatch);
                } else {
                    console.log('Target player div not found in next match');
                }
            } else {
                console.log('Next match element not found:', nextMatchId);
            }
        }
        
        function updateBracketData(currentRound, currentMatch, nextRound, nextMatch, winnerName) {
            // Update the bracket data structure to reflect the winner progression
            if (bracketData.currentRounds && bracketData.currentRounds.length > nextRound - 1) {
                const nextRoundData = bracketData.currentRounds[nextRound - 1];
                if (nextRoundData && nextRoundData.length > nextMatch - 1) {
                    // Update the bracket data with the winner
                    const targetPosition = (currentMatch % 2 === 1) ? 0 : 1;
                    nextRoundData[nextMatch - 1][targetPosition] = winnerName;
                    
                    console.log('Updated bracket data:', nextRoundData[nextMatch - 1]);
                }
            }
        }
        
        function checkAndAddArrowToNextMatch(nextMatchElement, nextRound, nextMatch) {
            console.log('Checking if next match is ready for arrow:', nextRound, nextMatch);
            
            // Check if both players are known (not BYE, not "Winner of Match", not TBD)
            const playerDivs = nextMatchElement.querySelectorAll('.player');
            if (playerDivs.length >= 2) {
                const player1Text = playerDivs[0].textContent.trim();
                const player2Text = playerDivs[1].textContent.trim();
                
                console.log('Player 1 text:', player1Text);
                console.log('Player 2 text:', player2Text);
                
                // Check if both players are valid (not BYE, not placeholder text)
                const isPlayer1Valid = isValidPlayer(player1Text);
                const isPlayer2Valid = isValidPlayer(player2Text);
                
                console.log('Player 1 valid:', isPlayer1Valid);
                console.log('Player 2 valid:', isPlayer2Valid);
                
                if (isPlayer1Valid && isPlayer2Valid) {
                    // Both players are known, add arrow if not already present
                    const existingArrow = nextMatchElement.querySelector('.match-arrow');
                    if (!existingArrow) {
                        console.log('Adding arrow to next match');
                        addArrowToMatch(nextMatchElement, nextRound, nextMatch);
                    } else {
                        console.log('Arrow already exists for next match');
                    }
                } else {
                    console.log('Next match not ready - one or both players not valid');
                }
            }
        }
        
        function isValidPlayer(playerText) {
            // Check if player text is valid (not BYE, not placeholder text)
            const lowerText = playerText.toLowerCase();
            return !lowerText.includes('bye') && 
                   !lowerText.includes('winner of match') && 
                   !lowerText.includes('tbd') && 
                   !lowerText.includes('to be determined') &&
                   playerText.trim().length > 0;
        }
        
        function addArrowToMatch(matchElement, roundIndex, matchIndex) {
            // Create and add arrow to the match
            const arrowDiv = document.createElement('div');
            arrowDiv.className = 'match-arrow';
            
            arrowDiv.addEventListener('click', function(e) {
                e.stopPropagation();
                
                // Get actual player names from the match element
                let player1Name = 'Player 1';
                let player2Name = 'Player 2';
                
                const playerDivs = matchElement.querySelectorAll('.player');
                if (playerDivs.length >= 2) {
                    const player1Text = playerDivs[0].textContent.trim();
                    player1Name = player1Text.replace(/✓$/, '').trim();
                    
                    const player2Text = playerDivs[1].textContent.trim();
                    player2Name = player2Text.replace(/✓$/, '').trim();
                }
                
                // Create match data for the modal
                const matchData = {
                    matchId: matchElement.id,
                    player1: player1Name,
                    player2: player2Name,
                    scores: null
                };
                openMatchResultsModal(matchData);
            });
            
            matchElement.appendChild(arrowDiv);
            console.log('Arrow added to match:', matchElement.id);
        }
        
        // Close modal when clicking outside of it
        window.onclick = function(event) {
            const modal = document.getElementById('matchResultsModal');
            if (event.target === modal) {
                closeMatchResultsModal();
            }
        }

        function alignBracketRounds() {
            const rounds = document.querySelectorAll('.round');
            if (rounds.length < 2) return;

            console.log('Starting bracket alignment...');

            // First, align all round titles to the same height
            const firstRoundTitle = rounds[0].querySelector('.round-title');
            const firstRoundTitleTop = firstRoundTitle.offsetTop;

            for (let i = 1; i < rounds.length; i++) {
                const round = rounds[i];
                const roundTitle = round.querySelector('.round-title');
                
                if (roundTitle) {
                    const currentTop = roundTitle.offsetTop;
                    const titleOffset = firstRoundTitleTop - currentTop;
                    round.style.transform = `translateY(${titleOffset}px)`;
                    console.log(`Round ${i + 1} title offset: ${titleOffset}px`);
                }
            }

            // Now align matches - handle each round progressively
            for (let roundIndex = 1; roundIndex < rounds.length; roundIndex++) {
                const currentRound = rounds[roundIndex];
                const currentMatches = currentRound.querySelectorAll('.match');

                console.log(`Aligning round ${roundIndex + 1} with ${currentMatches.length} matches`);

                currentMatches.forEach((currentMatch, matchIndex) => {
                    // Calculate the target position based on the first round matches
                    const targetPosition = calculateTargetPosition(roundIndex, matchIndex, rounds);
                    
                    if (targetPosition !== null) {
                        // Get current match position
                        const currentMatchTop = currentMatch.offsetTop;
                        const currentMatchHeight = currentMatch.offsetHeight;
                        const currentMatchCenter = currentMatchTop + currentMatchHeight / 2;
                        
                        // Calculate the offset needed
                        const offset = targetPosition - currentMatchCenter;
                        
                        console.log(`Round ${roundIndex + 1}, Match ${matchIndex + 1}: Target: ${targetPosition}, Current: ${currentMatchCenter}, Offset: ${offset}`);
                        
                        // Apply the offset
                        if (Math.abs(offset) > 2) {
                            currentMatch.style.transform = `translateY(${offset}px)`;
                            currentMatch.style.transition = 'transform 0.3s ease';
                        }
                    }
                });
            }
            
            console.log('Bracket alignment completed');
        }

        function calculateTargetPosition(roundIndex, matchIndex, rounds) {
            // Use the immediate previous round matches as reference (this was working well for 2nd round)
            const previousRound = rounds[roundIndex - 1];
            const previousMatches = previousRound.querySelectorAll('.match');
            
            if (previousMatches.length === 0) return null;
            
            // Calculate which parent matches this current match should be centered between
            const parentMatch1Index = matchIndex * 2;
            const parentMatch2Index = parentMatch1Index + 1;
            
            if (parentMatch1Index >= previousMatches.length || parentMatch2Index >= previousMatches.length) {
                return null;
            }
            
            const parentMatch1 = previousMatches[parentMatch1Index];
            const parentMatch2 = previousMatches[parentMatch2Index];
            
            // Get the positions of the parent matches
            const parent1Top = parentMatch1.offsetTop;
            const parent2Top = parentMatch2.offsetTop;
            const parent1Height = parentMatch1.offsetHeight;
            const parent2Height = parentMatch2.offsetHeight;
            
            // Calculate the center between these parent matches
            const parent1Center = parent1Top + parent1Height / 2;
            const parent2Center = parent2Top + parent2Height / 2;
            const targetCenter = (parent1Center + parent2Center) / 2;
            
            console.log(`Calculating target for round ${roundIndex + 1}, match ${matchIndex + 1}: Parent matches ${parentMatch1Index + 1} and ${parentMatch2Index + 1}, Target center: ${targetCenter}`);
            
            return targetCenter;
        }

        function alignBracketRoundsSimple() {
            const rounds = document.querySelectorAll('.round');
            if (rounds.length < 2) return;

            console.log('Starting simple bracket alignment...');

            // Simple approach: use the same first-round reference method
            for (let roundIndex = 1; roundIndex < rounds.length; roundIndex++) {
                const currentRound = rounds[roundIndex];
                const currentMatches = currentRound.querySelectorAll('.match');

                console.log(`Simple alignment - Round ${roundIndex + 1} with ${currentMatches.length} matches`);

                currentMatches.forEach((currentMatch, matchIndex) => {
                    // Calculate the target position based on the first round matches
                    const targetPosition = calculateTargetPosition(roundIndex, matchIndex, rounds);
                    
                    if (targetPosition !== null) {
                        // Get current match position
                        const currentMatchTop = currentMatch.offsetTop;
                        const currentMatchHeight = currentMatch.offsetHeight;
                        const currentMatchCenter = currentMatchTop + currentMatchHeight / 2;
                        
                        // Calculate offset
                        const offset = targetPosition - currentMatchCenter;
                        
                        console.log(`Simple alignment - Round ${roundIndex + 1}, Match ${matchIndex + 1}: Target: ${targetPosition}, Current: ${currentMatchCenter}, Offset: ${offset}`);
                        
                        // Apply offset
                        if (Math.abs(offset) > 2) {
                            currentMatch.style.transform = `translateY(${offset}px)`;
                            currentMatch.style.transition = 'transform 0.3s ease';
                        }
                    }
                });
            }
            
            console.log('Simple bracket alignment completed');
        }

        function generateSeededBracketOrder(players, numPositions) {
            // Standard tournament seeding pattern
            // Seed 1 vs Seed 8, Seed 4 vs Seed 5, Seed 3 vs Seed 6, Seed 2 vs Seed 7
            // For larger brackets, this pattern repeats in each quarter
            
            const positions = new Array(numPositions);
            const numPlayers = players.length;
            
            // Handle different bracket sizes
            if (numPositions === 2) {
                // 2-player bracket
                positions[0] = players[0] || { name: 'BYE', seeding: 'BYE' };
                positions[1] = players[1] || { name: 'BYE', seeding: 'BYE' };
            } else if (numPositions === 4) {
                // 4-player bracket: 1 vs 4, 2 vs 3
                positions[0] = players[0] || { name: 'BYE', seeding: 'BYE' };
                positions[1] = players[3] || { name: 'BYE', seeding: 'BYE' };
                positions[2] = players[2] || { name: 'BYE', seeding: 'BYE' };
                positions[3] = players[1] || { name: 'BYE', seeding: 'BYE' };
            } else if (numPositions === 8) {
                // 8-player bracket: 1-8, 5-4, 3-6, 7-2
                positions[0] = players[0] || { name: 'BYE', seeding: 'BYE' };
                positions[1] = players[7] || { name: 'BYE', seeding: 'BYE' };
                positions[2] = players[4] || { name: 'BYE', seeding: 'BYE' };
                positions[3] = players[3] || { name: 'BYE', seeding: 'BYE' };
                positions[4] = players[2] || { name: 'BYE', seeding: 'BYE' };
                positions[5] = players[5] || { name: 'BYE', seeding: 'BYE' };
                positions[6] = players[6] || { name: 'BYE', seeding: 'BYE' };
                positions[7] = players[1] || { name: 'BYE', seeding: 'BYE' };
            } else if (numPositions === 16) {
                // 16-player bracket
                positions[0] = players[0] || { name: 'BYE', seeding: 'BYE' };   // 1
                positions[1] = players[15] || { name: 'BYE', seeding: 'BYE' };  // 16
                positions[2] = players[8] || { name: 'BYE', seeding: 'BYE' };   // 9
                positions[3] = players[7] || { name: 'BYE', seeding: 'BYE' };   // 8
                positions[4] = players[4] || { name: 'BYE', seeding: 'BYE' };   // 5
                positions[5] = players[11] || { name: 'BYE', seeding: 'BYE' };  // 12
                positions[6] = players[12] || { name: 'BYE', seeding: 'BYE' };  // 13
                positions[7] = players[3] || { name: 'BYE', seeding: 'BYE' };   // 4
                positions[8] = players[2] || { name: 'BYE', seeding: 'BYE' };   // 3
                positions[9] = players[13] || { name: 'BYE', seeding: 'BYE' };  // 14
                positions[10] = players[10] || { name: 'BYE', seeding: 'BYE' }; // 11
                positions[11] = players[5] || { name: 'BYE', seeding: 'BYE' };  // 6
                positions[12] = players[6] || { name: 'BYE', seeding: 'BYE' };  // 7
                positions[13] = players[9] || { name: 'BYE', seeding: 'BYE' };  // 10
                positions[14] = players[14] || { name: 'BYE', seeding: 'BYE' }; // 15
                positions[15] = players[1] || { name: 'BYE', seeding: 'BYE' };  // 2
            } else if (numPositions === 32) {
                // 32-player bracket - extended pattern
                const seedOrder = [1,32,17,16,9,24,25,8,5,28,21,12,13,20,29,4,3,30,19,14,11,22,27,6,7,26,23,10,15,18,31,2];
                for (let i = 0; i < numPositions; i++) {
                    const seedIndex = seedOrder[i] - 1;
                    positions[i] = players[seedIndex] || { name: 'BYE', seeding: 'BYE' };
                }
            } else {
                // For larger brackets, use a recursive approach
                const seedOrder = generateSeedOrder(numPositions);
                for (let i = 0; i < numPositions; i++) {
                    const seedIndex = seedOrder[i] - 1;
                    positions[i] = players[seedIndex] || { name: 'BYE', seeding: 'BYE' };
                }
            }
            
            return positions;
        }

        function generateSeedOrder(n) {
            if (n <= 1) return [1];
            if (n === 2) return [1, 2];
            if (n === 4) return [1, 4, 3, 2];
            if (n === 8) return [1, 8, 5, 4, 3, 6, 7, 2];
            if (n === 16) return [1,16,9,8,5,12,13,4,3,14,11,6,7,10,15,2];
            if (n === 32) return [1,32,17,16,9,24,25,8,5,28,21,12,13,20,29,4,3,30,19,14,11,22,27,6,7,26,23,10,15,18,31,2];
            
            // For larger brackets, generate recursively
            const half = n / 2;
            const firstHalf = generateSeedOrder(half);
            const secondHalf = firstHalf.map(x => n + 1 - x);
            
            const result = [];
            for (let i = 0; i < half; i++) {
                result.push(firstHalf[i]);
                result.push(secondHalf[i]);
            }
            return result;
        }



        function getBracketOrder(n) {
            if (n <= 1) return [1];
            const prev = getBracketOrder(Math.floor(n / 2));
            const res = [];
            for (let i = 0; i < prev.length; i++) {
                res.push(prev[i]);
                res.push(n + 1 - prev[i]);
            }
            return res;
        }

        function getRoundLabel(roundIndex, totalRounds) {
            const fromEnd = totalRounds - roundIndex;
            if (fromEnd === 1) return "Final";
            if (fromEnd === 2) return "Semi-Final";
            if (fromEnd === 3) return "Quarter-Final";
            if (fromEnd === 4) return "Round of 16";
            if (fromEnd === 5) return "Round of 32";
            if (fromEnd === 6) return "Round of 64";
            return `Round ${roundIndex + 1}`;
        }

        // Store match results
        const matchResults = {};

        function showScorePopup(roundIndex, matchIndex, match) {
            const popup = document.getElementById('successPopup');
            const overlay = document.getElementById('popupOverlay');
            const matchDetails = document.getElementById('matchDetails');
            const scoreForm = document.getElementById('scoreForm');
            
            document.getElementById('roundIndex').value = roundIndex;
            document.getElementById('matchIndex').value = matchIndex;
            
            const matchId = `${roundIndex}-${matchIndex}`;
            const result = matchResults[matchId];
            
            const player1Name = match[0]?.name || 'Player 1';
            const player2Name = match[1]?.name || 'Player 2';
            
            document.getElementById('player1NameHeader').textContent = player1Name;
            document.getElementById('player2NameHeader').textContent = player2Name;
            
            const hasBye = player1Name === 'BYE' || player2Name === 'BYE';
            
            if (hasBye) {
                scoreForm.classList.add('disabled');
                
                const byePlayer = player1Name === 'BYE' ? player2Name : player1Name;
                const byeMessage = document.createElement('div');
                byeMessage.className = 'bye-message';
                byeMessage.innerHTML = `<strong>${byePlayer}</strong> automatically advances to the next round due to a BYE.`;
                
                const columnsElement = document.querySelector('.player-columns');
                scoreForm.insertBefore(byeMessage, columnsElement);
                
                if (!matchResults[matchId]) {
                    const winner = player1Name === 'BYE' ? match[1] : match[0];
                    const scores = player1Name === 'BYE' 
                        ? [[0, 0, 0], [11, 11, 0]] 
                        : [[11, 11, 0], [0, 0, 0]];
                    
                    matchResults[matchId] = {
                        scores: scores,
                        winner: winner,
                        isBye: true
                    };
                }
                
                const scores = matchResults[matchId].scores;
                document.getElementById('player1Game1').value = scores[0][0] || '';
                document.getElementById('player1Game2').value = scores[0][1] || '';
                document.getElementById('player1Game3').value = scores[0][2] || '';
                
                document.getElementById('player2Game1').value = scores[1][0] || '';
                document.getElementById('player2Game2').value = scores[1][1] || '';
                document.getElementById('player2Game3').value = scores[1][2] || '';
            } else {
                scoreForm.classList.remove('disabled');
                
                const existingByeMessage = document.querySelector('.bye-message');
                if (existingByeMessage) {
                    existingByeMessage.remove();
                }
                
                if (result) {
                    document.getElementById('player1Game1').value = result.scores[0][0] || '';
                    document.getElementById('player1Game2').value = result.scores[0][1] || '';
                    document.getElementById('player1Game3').value = result.scores[0][2] || '';
                    
                    document.getElementById('player2Game1').value = result.scores[1][0] || '';
                    document.getElementById('player2Game2').value = result.scores[1][1] || '';
                    document.getElementById('player2Game3').value = result.scores[1][2] || '';
                } else {
                    document.getElementById('player1Game1').value = '';
                    document.getElementById('player1Game2').value = '';
                    document.getElementById('player1Game3').value = '';
                    
                    document.getElementById('player2Game1').value = '';
                    document.getElementById('player2Game2').value = '';
                    document.getElementById('player2Game3').value = '';
                }
            }
            
            popup.style.display = 'block';
            overlay.style.display = 'block';
        }

        document.getElementById('scoreForm').addEventListener('submit', function(e) {
            e.preventDefault();
            
            if (this.classList.contains('disabled')) {
                document.getElementById('successPopup').style.display = 'none';
                document.getElementById('popupOverlay').style.display = 'none';
                return;
            }
            
            const roundIndex = parseInt(document.getElementById('roundIndex').value);
            const matchIndex = parseInt(document.getElementById('matchIndex').value);
            const matchId = `${roundIndex}-${matchIndex}`;
            
            const roundElement = document.querySelectorAll('.round')[roundIndex];
            const matchElement = roundElement.querySelectorAll('.match')[matchIndex];
            const playerElements = matchElement.querySelectorAll('.player');
            
            const match = [
                { 
                    name: document.getElementById('player1NameHeader').textContent,
                    seeding: playerElements[0].querySelector('.seed') ? 
                             playerElements[0].querySelector('.seed').textContent.replace(/[()]/g, '') : 
                             ''
                },
                { 
                    name: document.getElementById('player2NameHeader').textContent,
                    seeding: playerElements[1].querySelector('.seed') ? 
                             playerElements[1].querySelector('.seed').textContent.replace(/[()]/g, '') : 
                             ''
                }
            ];
            
            const scores = [
                [
                    parseInt(document.getElementById('player1Game1').value) || 0,
                    parseInt(document.getElementById('player1Game2').value) || 0,
                    parseInt(document.getElementById('player1Game3').value) || 0
                ],
                [
                    parseInt(document.getElementById('player2Game1').value) || 0,
                    parseInt(document.getElementById('player2Game2').value) || 0,
                    parseInt(document.getElementById('player2Game3').value) || 0
                ]
            ];
            
            let player1Wins = 0;
            let player2Wins = 0;
            
            for (let i = 0; i < 3; i++) {
                if (scores[0][i] > scores[1][i]) player1Wins++;
                else if (scores[1][i] > scores[0][i]) player2Wins++;
            }
            
            let winner;
            if (player1Wins > player2Wins) {
                winner = match[0];
            } else if (player2Wins > player1Wins) {
                winner = match[1];
            } else {
                alert("Match must have a winner. Please ensure one player wins more games.");
                return;
            }
            
            matchResults[matchId] = {
                scores: scores,
                winner: winner
            };
            
            // Update the bracket with the winner
            updateBracketWithWinner(roundIndex, matchIndex, winner);
            
            document.getElementById('successPopup').style.display = 'none';
            document.getElementById('popupOverlay').style.display = 'none';
        });

        function updateBracketWithWinner(roundIndex, matchIndex, winner) {
            // Calculate the next round and match indices
            const nextRoundIndex = roundIndex + 1;
            const nextMatchIndex = Math.floor(matchIndex / 2);
            
            // Check if there is a next round
            if (nextRoundIndex < bracketData.currentRounds.length) {
                // Get the next round's match
                const nextRound = bracketData.currentRounds[nextRoundIndex];
                const nextMatch = nextRound[nextMatchIndex];
                
                // Determine which position in the next match to update
                const positionInNextMatch = matchIndex % 2;
                
                // Update the player in the next match
                nextMatch[positionInNextMatch] = winner;
                
                // Update the visual representation
                const nextMatchElement = document.querySelector(`#round-${nextRoundIndex + 1}-match-${nextMatchIndex + 1}`);
                if (nextMatchElement) {
                    const playerElements = nextMatchElement.querySelectorAll('.player');
                    const playerElement = playerElements[positionInNextMatch];
                    
                    // Update the player name and seeding
                    const nameSpan = playerElement.querySelector('span');
                    nameSpan.textContent = winner.name;
                    
                    // Update or add seeding if it exists
                    let seedSpan = playerElement.querySelector('.seed');
                    if (winner.seeding) {
                        if (!seedSpan) {
                            seedSpan = document.createElement('span');
                            seedSpan.className = 'seed';
                            playerElement.appendChild(seedSpan);
                        }
                        seedSpan.textContent = `(${winner.seeding})`;
                    } else if (seedSpan) {
                        seedSpan.remove();
                    }
                    
                    // Add click handler for player swapping
                    nameSpan.addEventListener('click', function(e) {
                        e.stopPropagation();
                        showSwapPopup(nextRoundIndex, nextMatchIndex, positionInNextMatch, winner);
                    });
                }
            }
        }

        function regenerateBracket() {
            const category = document.getElementById('categorySelect').value;
            if (category) {
                fetch(`/tournament/{{ tournament['Tournament Id'] }}/get_category_players/${category}`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.players) {
                            generateBracket(data.players);
                        }
                    })
                    .catch(error => {
                        console.error('Error fetching players:', error);
                    });
            }
        }

        document.getElementById('closePopup').addEventListener('click', function(e) {
            e.preventDefault();
            
            const existingByeMessage = document.querySelector('.bye-message');
            if (existingByeMessage) {
                existingByeMessage.remove();
            }
            
            document.getElementById('successPopup').style.display = 'none';
            document.getElementById('popupOverlay').style.display = 'none';
        });
        
        document.getElementById('popupOverlay').addEventListener('click', function() {
            const existingByeMessage = document.querySelector('.bye-message');
            if (existingByeMessage) {
                existingByeMessage.remove();
            }
            
            document.getElementById('successPopup').style.display = 'none';
            document.getElementById('popupOverlay').style.display = 'none';
        });

        function showSwapPopup(roundIndex, matchIndex, playerIndex, player) {
            const popup = document.getElementById('swapPopup');
            const overlay = document.getElementById('popupOverlay');
            const swapDetails = document.getElementById('swapDetails');
            const swapOptions = document.getElementById('swapOptions');
            
            // Store the current selection
            bracketData.selectedRound = roundIndex;
            bracketData.selectedMatch = matchIndex;
            bracketData.selectedPlayerIndex = playerIndex;
            bracketData.selectedPlayer = player;
            bracketData.targetPlayer = null;
            
            // Update swap details
            swapDetails.innerHTML = `Swapping: <strong>${player.name}</strong>${player.seeding ? ` (Seed: ${player.seeding})` : ''}`;
            
            // Get all eligible players for swapping
            const playersInRound = [];
            bracketData.currentRounds[roundIndex].forEach((match, mIdx) => {
                match.forEach((p, pIdx) => {
                    if (p.name !== 'BYE' && 
                        !p.name.startsWith('Winner of Match') && 
                        !(mIdx === matchIndex && pIdx === playerIndex)) {
                        playersInRound.push({
                            player: p,
                            matchIndex: mIdx,
                            playerIndex: pIdx
                        });
                    }
                });
            });
            
            // Clear and populate swap options
            swapOptions.innerHTML = '';
            playersInRound.forEach(option => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'swap-option';
                optionDiv.innerHTML = `
                    ${option.player.name}
                    ${option.player.seeding ? `<span class="swap-seed">(Seed: ${option.player.seeding})</span>` : ''}
                `;
                
                optionDiv.addEventListener('click', function() {
                    // Remove selected class from all options
                    document.querySelectorAll('.swap-option').forEach(el => {
                        el.classList.remove('selected');
                    });
                    
                    // Add selected class to clicked option
                    this.classList.add('selected');
                    
                    // Store the target player
                    bracketData.targetPlayer = {
                        player: option.player,
                        matchIndex: option.matchIndex,
                        playerIndex: option.playerIndex
                    };
                });
                
                swapOptions.appendChild(optionDiv);
            });
            
            // Show popup and overlay
            popup.style.display = 'block';
            overlay.style.display = 'block';
        }

        document.getElementById('confirmSwap').addEventListener('click', function() {
            if (!bracketData.targetPlayer) {
                alert('Please select a player to swap with');
                return;
            }
            
            // Get the current round
            const round = bracketData.currentRounds[bracketData.selectedRound];
            
            // Perform the swap in the data structure
            const temp = round[bracketData.selectedMatch][bracketData.selectedPlayerIndex];
            round[bracketData.selectedMatch][bracketData.selectedPlayerIndex] = round[bracketData.targetPlayer.matchIndex][bracketData.targetPlayer.playerIndex];
            round[bracketData.targetPlayer.matchIndex][bracketData.targetPlayer.playerIndex] = temp;
            
            // Update the visual representation
            const selectedMatchElement = document.querySelector(`#round-${bracketData.selectedRound + 1}-match-${bracketData.selectedMatch + 1}`);
            const targetMatchElement = document.querySelector(`#round-${bracketData.selectedRound + 1}-match-${bracketData.targetPlayer.matchIndex + 1}`);
            
            if (selectedMatchElement && targetMatchElement) {
                const selectedPlayerElement = selectedMatchElement.querySelectorAll('.player')[bracketData.selectedPlayerIndex];
                const targetPlayerElement = targetMatchElement.querySelectorAll('.player')[bracketData.targetPlayer.playerIndex];
                
                // Update selected player
                const selectedNameSpan = selectedPlayerElement.querySelector('span');
                selectedNameSpan.textContent = round[bracketData.selectedMatch][bracketData.selectedPlayerIndex].name;
                
                // Update selected player seeding
                let selectedSeedSpan = selectedPlayerElement.querySelector('.seed');
                if (round[bracketData.selectedMatch][bracketData.selectedPlayerIndex].seeding) {
                    if (!selectedSeedSpan) {
                        selectedSeedSpan = document.createElement('span');
                        selectedSeedSpan.className = 'seed';
                        selectedPlayerElement.appendChild(selectedSeedSpan);
                    }
                    selectedSeedSpan.textContent = `(${round[bracketData.selectedMatch][bracketData.selectedPlayerIndex].seeding})`;
                } else if (selectedSeedSpan) {
                    selectedSeedSpan.remove();
                }
                
                // Update target player
                const targetNameSpan = targetPlayerElement.querySelector('span');
                targetNameSpan.textContent = round[bracketData.targetPlayer.matchIndex][bracketData.targetPlayer.playerIndex].name;
                
                // Update target player seeding
                let targetSeedSpan = targetPlayerElement.querySelector('.seed');
                if (round[bracketData.targetPlayer.matchIndex][bracketData.targetPlayer.playerIndex].seeding) {
                    if (!targetSeedSpan) {
                        targetSeedSpan = document.createElement('span');
                        targetSeedSpan.className = 'seed';
                        targetPlayerElement.appendChild(targetSeedSpan);
                    }
                    targetSeedSpan.textContent = `(${round[bracketData.targetPlayer.matchIndex][bracketData.targetPlayer.playerIndex].seeding})`;
                } else if (targetSeedSpan) {
                    targetSeedSpan.remove();
                }
                
                // Update click handlers
                selectedNameSpan.addEventListener('click', function(e) {
                    e.stopPropagation();
                    showSwapPopup(bracketData.selectedRound, bracketData.selectedMatch, bracketData.selectedPlayerIndex, round[bracketData.selectedMatch][bracketData.selectedPlayerIndex]);
                });
                
                targetNameSpan.addEventListener('click', function(e) {
                    e.stopPropagation();
                    showSwapPopup(bracketData.selectedRound, bracketData.targetPlayer.matchIndex, bracketData.targetPlayer.playerIndex, round[bracketData.targetPlayer.matchIndex][bracketData.targetPlayer.playerIndex]);
                });
            }
            
            // Close the popup
            document.getElementById('swapPopup').style.display = 'none';
            document.getElementById('popupOverlay').style.display = 'none';
        });

        document.getElementById('closeSwapPopup').addEventListener('click', function() {
            document.getElementById('swapPopup').style.display = 'none';
            document.getElementById('popupOverlay').style.display = 'none';
        });

        // Function to sort table rows by seed while preserving S.No. column and range colors
        // Features:
        // - Sorts rows in ascending order of seed values
        // - Preserves original range colors during sorting
        // - Cascaded animation: upward movements animate first, then downward movements
        // - Different visual feedback for upward vs downward movements
        // - Enhanced performance using CSS classes instead of inline styles
        window.sortTableBySeedClash = function() {
            console.log('sortTableBySeedClash called');
            const tbody = document.getElementById('clashTableBody');
            console.log('Found tbody:', tbody);
            if (!tbody) {
                console.error('clashTableBody not found');
                return;
            }
            
            const rows = Array.from(tbody.getElementsByTagName('tr'));
            if (rows.length === 0) {
                console.log('No rows found');
                return;
            }
            
            console.log('Found rows:', rows.length);
            
            // Create array of row data with seed values for sorting
            const rowData = rows.map((row, index) => {
                const seedCell = row.cells[2]; // Seed column (3rd column, index 2)
                let seedValue = 999999; // Default for unseeded players
                
                // Extract seed value from the cell
                if (seedCell.innerHTML.includes('<input')) {
                    // If it's an input, get the value
                    const input = seedCell.querySelector('input');
                    seedValue = input ? (parseInt(input.value) || 999999) : 999999;
                } else if (seedCell.innerHTML.includes('<select')) {
                    // If it's a select, get the value
                    const select = seedCell.querySelector('select');
                    seedValue = select ? (parseInt(select.value) || 999999) : 999999;
                } else {
                    // If it's plain text, parse the text content
                    seedValue = parseInt(seedCell.textContent.trim()) || 999999;
                }
                
                console.log(`Row ${index}: seed value = ${seedValue}`);
                
                return {
                    row: row,
                    seed: seedValue,
                    originalIndex: index,
                    originalClass: row.className // Preserve original color class
                };
            });
            
            // Sort by seed value (ascending)
            rowData.sort((a, b) => a.seed - b.seed);
            console.log('Sorted rowData:', rowData.map(d => ({ seed: d.seed, originalIndex: d.originalIndex })));
            
            // Capture positions BEFORE moving rows
            const originalPositions = [];
            rowData.forEach((data, index) => {
                const rect = data.row.getBoundingClientRect();
                originalPositions.push({
                    row: data.row,
                    top: rect.top,
                    originalIndex: data.originalIndex
                });
            });
            
            // Clear the table and re-add rows in sorted order
            tbody.innerHTML = '';
            rowData.forEach((data, newIndex) => {
                // Update S.No. to reflect the new sequential position (1, 2, 3...)
                const snoCell = data.row.cells[0];
                snoCell.textContent = (newIndex + 1).toString();
                
                // Preserve the original color class (range colors) - this maintains the animation
                data.row.className = data.originalClass;
                
                // Add the row back to the table
                tbody.appendChild(data.row);
            });
            
            // Enhanced Cascaded FLIP Animation: Show rows moving in a cascaded sequence
            requestAnimationFrame(() => {
                // Add loading indicator during animation
                tbody.style.opacity = '0.8';
                tbody.style.pointerEvents = 'none';
                
                // Get new positions AFTER moving rows
                const newPositions = [];
                rowData.forEach((data, index) => {
                    const rect = data.row.getBoundingClientRect();
                    newPositions.push({
                        row: data.row,
                        top: rect.top,
                        newIndex: index
                    });
                });
                
                // Find rows that actually moved
                const movedRows = [];
                originalPositions.forEach((original, index) => {
                    const newPos = newPositions.find(np => np.row === original.row);
                    if (newPos && Math.abs(original.top - newPos.top) > 1) { // More than 1px difference
                        const dy = original.top - newPos.top;
                        movedRows.push({
                            row: original.row,
                            dy: dy,
                            originalIndex: original.originalIndex,
                            newIndex: newPos.newIndex,
                            direction: dy > 0 ? 'up' : 'down'
                        });
                        console.log(`Row ${original.originalIndex} moved by ${dy}px (${dy > 0 ? 'up' : 'down'})`);
                    }
                });
                
                console.log(`Found ${movedRows.length} rows that moved`);
                console.log('Moved rows details:', movedRows.map(move => ({
                    originalIndex: move.originalIndex,
                    newIndex: move.newIndex,
                    direction: move.direction,
                    dy: move.dy
                })));
                
                if (movedRows.length === 0) {
                    console.log('No rows moved, skipping animation');
                    // Restore table interactivity immediately if no animation
                    tbody.style.opacity = '';
                    tbody.style.pointerEvents = '';
                    return;
                }
                
                // Sort moved rows by direction and distance for cascaded effect
                movedRows.sort((a, b) => {
                    // First sort by direction (up first, then down)
                    if (a.direction !== b.direction) {
                        return a.direction === 'up' ? -1 : 1;
                    }
                    // Then sort by distance (larger movements first)
                    return Math.abs(b.dy) - Math.abs(a.dy);
                });
                
                // Step 1: Move rows back to their original positions with enhanced styling
                movedRows.forEach((move, index) => {
                    move.row.style.transition = 'none';
                    move.row.style.transform = `translateY(${move.dy}px)`;
                    move.row.style.zIndex = 1000 + index; // Stack order for cascaded effect
                    
                    // Add CSS classes for better performance
                    move.row.classList.add('cascaded-moving', move.direction);
                });
                
                // Step 2: Cascaded animation to new positions
                let i = 0;
                function animateNext() {
                    if (i >= movedRows.length) {
                        // Clean up after all animations complete
                        setTimeout(() => {
                            movedRows.forEach(move => {
                                move.row.classList.remove('cascaded-moving', 'up', 'down', 'animating');
                                move.row.style.zIndex = '';
                                move.row.style.transform = '';
                            });
                            
                                                    // Restore table interactivity
                        tbody.style.opacity = '';
                        tbody.style.pointerEvents = '';
                        
                        // Update colors based on actual seed values after animation completes
                        updateRowColorsAfterSort();
                    }, 300);
                    return;
                }
                    
                    const move = movedRows[i];
                    console.log(`Animating row ${move.originalIndex} to position ${move.newIndex} (${move.direction})`);
                    
                    // Enhanced cascaded animation with different timing based on direction
                    const animationDuration = move.direction === 'up' ? 1000 : 1200;
                    move.row.style.transition = `transform ${animationDuration}ms cubic-bezier(0.4,0,0.2,1), background-color ${animationDuration}ms ease, box-shadow ${animationDuration}ms ease, border ${animationDuration}ms ease`;
                    move.row.style.transform = '';
                    
                    // Change color during animation to show progress
                    setTimeout(() => {
                        move.row.classList.add('animating');
                    }, 200);
                    
                    i++;
                    // Cascaded delay: shorter delay for upward movements, longer for downward
                    const delay = move.direction === 'up' ? 200 : 400;
                    setTimeout(animateNext, delay);
                }
                
                // Start cascaded animation after a small delay
                setTimeout(animateNext, 200);
            });
            
            console.log('Table sorted successfully with cascaded animation');
            
            // Update clash detection based on current input values
            updateClashDetection();
        }

        // Function to update clash detection based on current input values
        window.updateClashDetection = function() {
            const tbody = document.getElementById('clashTableBody');
            if (!tbody) return;
            
            const rows = Array.from(tbody.getElementsByTagName('tr'));
            const currentPlayers = [];
            
            // Extract current player data from the table
            rows.forEach((row, index) => {
                const nameCell = row.cells[1];
                const seedCell = row.cells[2];
                let seedValue = '';
                
                // Get seed value from input or text
                if (seedCell.innerHTML.includes('<input')) {
                    const input = seedCell.querySelector('input');
                    seedValue = input ? input.value : '';
                } else if (seedCell.innerHTML.includes('<select')) {
                    const select = seedCell.querySelector('select');
                    seedValue = select ? select.value : '';
                } else {
                    seedValue = seedCell.textContent.trim();
                }
                2185
                
                // Extract player_id from the input if it exists
                let playerId = '';
                if (seedCell.innerHTML.includes('player_id')) {
                    const match = seedCell.innerHTML.match(/player_id', '([^']+)'/);
                    if (match) {
                        playerId = match[1];
                    }
                }
                
                currentPlayers.push({
                    name: nameCell.textContent.trim(),
                    seeding: seedValue,
                    player_id: playerId,
                    originalIndex: index
                });
            });
            
            // Fetch seed ranges and detect clashes
            fetch('/get_seeding_ranges')
                .then(response => response.json())
                .then(seedRangesData => {
                    if (seedRangesData.success) {
                        const seedRanges = seedRangesData.seeding_ranges;
                        const clashes = detectSeedingClashes(currentPlayers, seedRanges);
                        
                        if (clashes.length > 0) {
                            showClashSummary(clashes);
                        } else {
                            const clashSummary = document.getElementById('clashSummary');
                            if (clashSummary) {
                                clashSummary.style.display = 'none';
                            }
                        }
                    }
                })
                .catch(error => {
                    console.error('Error updating clash detection:', error);
                });
        }

        // Function to update row colors based on S.No. positions after sorting
        function updateRowColorsAfterSort() {
            const tbody = document.getElementById('clashTableBody');
            if (!tbody) return;
            
            const rows = Array.from(tbody.getElementsByTagName('tr'));
            
            // Fetch seed ranges and update colors
            fetch('/get_seeding_ranges')
                .then(response => response.json())
                .then(seedRangesData => {
                    if (seedRangesData.success) {
                        const seedRanges = seedRangesData.seeding_ranges;
                        
                        rows.forEach((row, index) => {
                            const snoCell = row.cells[0];
                            const serialNumber = parseInt(snoCell.textContent);
                            
                            if (serialNumber) {
                                const seedRangeClass = getSeedRangeClass(serialNumber, seedRanges);
                                row.className = seedRangeClass;
                                console.log(`Updated row ${index + 1}: S.No. ${serialNumber} -> Color class: ${seedRangeClass}`);
                            }
                        });
                    }
                })
                .catch(error => {
                    console.error('Error updating row colors after sort:', error);
                });
        }

        // Global function for updating individual player seeding
        
    });
    </script>

    <!-- Add this before the closing </body> tag -->
    <div class="popup-overlay" id="popupOverlay"></div>
    <div class="success-popup" id="successPopup">
        <h3>Match Details</h3>
        <div id="matchDetails"></div>
        
        <form id="scoreForm" class="score-form">
            <input type="hidden" id="roundIndex" name="roundIndex">
            <input type="hidden" id="matchIndex" name="matchIndex">
            
            <div class="player-columns">
                <div class="player-column" id="player1NameHeader"></div>
                <div class="player-column" id="player2NameHeader"></div>
            </div>
            
            <div class="score-row">
                <label>Game 1:</label>
                <div class="score-inputs">
                    <input type="number" id="player1Game1" name="player1Game1" class="score-input" min="0" placeholder="0">
                    <input type="number" id="player2Game1" name="player2Game1" class="score-input" min="0" placeholder="0">
                </div>
            </div>
            
            <div class="score-row">
                <label>Game 2:</label>
                <div class="score-inputs">
                    <input type="number" id="player1Game2" name="player1Game2" class="score-input" min="0" placeholder="0">
                    <input type="number" id="player2Game2" name="player2Game2" class="score-input" min="0" placeholder="0">
                </div>
            </div>
            
            <div class="score-row">
                <label>Game 3:</label>
                <div class="score-inputs">
                    <input type="number" id="player1Game3" name="player1Game3" class="score-input" min="0" placeholder="0">
                    <input type="number" id="player2Game3" name="player2Game3" class="score-input" min="0" placeholder="0">
                </div>
            </div>
            
            <div class="button-group">
                <button type="button" class="cancel-btn" id="closePopup">Cancel</button>
                <button type="submit" class="save-btn">Save Scores</button>
            </div>
        </form>
    </div>

    <!-- Add this for the player swap popup -->
    <div class="swap-popup" id="swapPopup">
        <h3>Swap Player</h3>
        <div id="swapDetails"></div>
        
        <div class="swap-content">
            <p>Select a player to swap with:</p>
            <div class="swap-options" id="swapOptions">
                <!-- Player options will be generated here -->
            </div>
        </div>
        
        <div class="button-group">
            <button type="button" class="cancel-btn" id="closeSwapPopup">Cancel</button>
            <button type="button" class="save-btn" id="confirmSwap">Confirm Swap</button>
        </div>
    </div>

    <div class="shuffle-counter" id="shuffleCounter" style="display: none;">
        Shuffles: <span id="shuffleCount">0</span>
    </div>

    <script>
        // Global function for sorting table by seed
        function sortTableBySeed() {
            console.log('sortTableBySeed called');
            const tbody = document.getElementById('clashTableBody');
            if (!tbody) {
                console.error('clashTableBody not found');
                return;
            }
            
            const rows = Array.from(tbody.getElementsByTagName('tr'));
            if (rows.length === 0) {
                console.log('No rows found');
                return;
            }
            
            console.log('Found rows:', rows.length);
            
            // Create array of row data with seed values for sorting
            const rowData = rows.map((row, index) => {
                const seedCell = row.cells[2]; // Seed column (3rd column, index 2)
                let seedValue = 999999; // Default for unseeded players
                
                // Extract seed value from the cell
                if (seedCell.innerHTML.includes('<input')) {
                    // If it's an input, get the value
                    const input = seedCell.querySelector('input');
                    seedValue = input ? (parseInt(input.value) || 999999) : 999999;
                } else if (seedCell.innerHTML.includes('<select')) {
                    // If it's a select, get the value
                    const select = seedCell.querySelector('select');
                    seedValue = select ? (parseInt(select.value) || 999999) : 999999;
                } else {
                    // If it's plain text, parse the text content
                    seedValue = parseInt(seedCell.textContent.trim()) || 999999;
                }
                
                console.log(`Row ${index}: seed value = ${seedValue}`);
                
                return {
                    row: row,
                    seed: seedValue,
                    originalIndex: index
                };
            });
            
            // Sort by seed value (ascending)
            rowData.sort((a, b) => a.seed - b.seed);
            console.log('Sorted rowData:', rowData.map(d => ({ seed: d.seed, originalIndex: d.originalIndex })));
            
            // Capture positions BEFORE moving rows
            const originalPositions = [];
            rowData.forEach((data, index) => {
                const rect = data.row.getBoundingClientRect();
                originalPositions.push({
                    row: data.row,
                    top: rect.top,
                    originalIndex: data.originalIndex
                });
            });
            
            // Clear the table and re-add rows in sorted order
            tbody.innerHTML = '';
            rowData.forEach((data, newIndex) => {
                // Update S.No. to reflect the new sequential position (1, 2, 3...)
                const snoCell = data.row.cells[0];
                snoCell.textContent = (newIndex + 1).toString();
                
                // Add the row back to the table
                tbody.appendChild(data.row);
            });
            
            // Enhanced FLIP Animation: Show rows actually moving with better visual feedback
            requestAnimationFrame(() => {
                // Get new positions AFTER moving rows
                const newPositions = [];
                rowData.forEach((data, index) => {
                    const rect = data.row.getBoundingClientRect();
                    newPositions.push({
                        row: data.row,
                        top: rect.top,
                        newIndex: index
                    });
                });
                
                // Find rows that actually moved
                const movedRows = [];
                originalPositions.forEach((original, index) => {
                    const newPos = newPositions.find(np => np.row === original.row);
                    if (newPos && Math.abs(original.top - newPos.top) > 1) { // More than 1px difference
                        const dy = original.top - newPos.top;
                        movedRows.push({
                            row: original.row,
                            dy: dy,
                            originalIndex: original.originalIndex,
                            newIndex: newPos.newIndex
                        });
                        console.log(`Row ${original.originalIndex} moved by ${dy}px`);
                    }
                });
                
                console.log(`Found ${movedRows.length} rows that moved`);
                
                if (movedRows.length === 0) {
                    console.log('No rows moved, skipping animation');
                    return;
                }
                
                // Step 1: Move rows back to their original positions with enhanced styling
                movedRows.forEach(move => {
                    move.row.style.transition = 'none';
                    move.row.style.transform = `translateY(${move.dy}px)`;
                    move.row.style.backgroundColor = '#fff3cd'; // Light yellow background
                    move.row.style.zIndex = '1000';
                    move.row.style.boxShadow = '0 4px 12px rgba(0,0,0,0.3)';
                    move.row.style.border = '2px solid #ffc107'; // Yellow border
                    move.row.style.borderRadius = '4px';
                });
                
                // Step 2: Animate to new positions sequentially with improved timing
                let i = 0;
                function animateNext() {
                    if (i >= movedRows.length) {
                        // Clean up after all animations complete
                        setTimeout(() => {
                            movedRows.forEach(move => {
                                move.row.style.backgroundColor = '';
                                move.row.style.zIndex = '';
                                move.row.style.boxShadow = '';
                                move.row.style.border = '';
                                move.row.style.borderRadius = '';
                            });
                        }, 200);
                        return;
                    }
                    
                    const move = movedRows[i];
                    console.log(`Animating row ${move.originalIndex} to position ${move.newIndex}`);
                    
                    // Enhanced animation with better easing and longer duration
                    move.row.style.transition = 'transform 1200ms cubic-bezier(0.4,0,0.2,1), background-color 1200ms ease, box-shadow 1200ms ease, border 1200ms ease';
                    move.row.style.transform = '';
                    
                    // Change color during animation to show progress
                    setTimeout(() => {
                        move.row.style.backgroundColor = '#d4edda'; // Light green during movement
                        move.row.style.borderColor = '#28a745'; // Green border
                    }, 300);
                    
                    i++;
                    setTimeout(animateNext, 300); // 300ms delay between each row for better visibility
                }
                
                // Start animation after a small delay
                setTimeout(animateNext, 150);
            });
            
            console.log('Table sorted successfully');
            
            // Update color coding based on new S.No. positions
            updateColorCodingAfterSort();
            
            // Update clash detection based on current input values
            updateClashDetection();
        }

        // Function to get valid seed range for a clash group
        window.getValidSeedRangeForClash = function(playersWithRankings, currentSeed) {
            // Find all players with the same seed value
            const clashPlayers = playersWithRankings.filter(p => parseInt(p.seeding) === parseInt(currentSeed));
            
            if (clashPlayers.length === 0) {
                return { min: 1, max: playersWithRankings.length };
            }
            
            // Get the S.No. values (index + 1) of all clash players
            const clashSNoValues = clashPlayers.map((player, index) => {
                const playerIndex = playersWithRankings.findIndex(p => p.player_id === player.player_id);
                return playerIndex + 1;
            });
            
            // Return the min and max S.No. values as the valid range
            const min = Math.min(...clashSNoValues);
            const max = Math.max(...clashSNoValues);
            
            console.log(`Clash group for seed ${currentSeed}: S.No. range ${min}-${max} (${clashPlayers.length} players)`);
            return { min, max };
        }

        // Function to get dynamic color for seed value
        function getDynamicColorForSeed(seedValue) {
            const colorMap = {
                1: 'rgba(255, 193, 7, 0.8)',   // Yellow
                2: 'rgba(33, 150, 243, 0.8)',  // Blue
                3: 'rgba(76, 175, 80, 0.8)',   // Green
                4: 'rgba(244, 67, 54, 0.8)',   // Red
                5: 'rgba(156, 39, 176, 0.8)',  // Purple
                6: 'rgba(255, 152, 0, 0.8)',   // Orange
                7: 'rgba(158, 158, 158, 0.8)', // Gray
                8: 'rgba(0, 150, 136, 0.8)',   // Teal
                9: 'rgba(233, 30, 99, 0.8)',   // Pink
                10: 'rgba(139, 195, 74, 0.8)', // Light Green
                11: 'rgba(255, 87, 34, 0.8)',  // Deep Orange
                12: 'rgba(121, 85, 72, 0.8)',  // Brown
                13: 'rgba(96, 125, 139, 0.8)', // Blue Gray
                14: 'rgba(255, 235, 59, 0.8)', // Lime
                15: 'rgba(0, 188, 212, 0.8)',  // Cyan
                16: 'rgba(255, 64, 129, 0.8)'  // Pink
            };
            return colorMap[seedValue] || 'rgba(76, 175, 80, 0.8)'; // Default to green for any other seed values
        }

        // Function to handle seed change events
        function handleSeedChange(event) {
            console.log('handleSeedChange called with event:', event);
            const input = event.target;
            if (validateSeedInput(input)) {
                console.log('Validation passed, triggering animation');
                // Trigger animation after validation passes
                setTimeout(() => {
                    // Call the enhanced sortTableBySeed function for clash resolution
                    console.log('Calling sortTableBySeedClash...');
                    sortTableBySeedClash();
                }, 100);
            } else {
                console.log('Validation failed, not triggering animation');
            }
        }

        // Function to validate seed input against clash group range
        function validateSeedInput(input) {
            const newSeed = parseInt(input.value);
            const playerId = input.getAttribute('data-player-id');
            
            console.log('validateSeedInput called:', { newSeed, playerId });
            
            // Use global players data
            const playersWithRankings = window.currentPlayersWithRankings;
            if (!playersWithRankings) {
                console.log('No global players data found');
                return true;
            }
            
            // Find the current player's seed
            const currentPlayer = playersWithRankings.find(p => p.player_id === playerId);
            if (!currentPlayer) {
                console.log('Current player not found');
                return true;
            }
            
            const currentSeed = parseInt(currentPlayer.seeding);
            const validRange = getValidSeedRangeForClash(playersWithRankings, currentSeed);
            
            console.log('Validation check:', { newSeed, currentSeed, validRange });
            
            if (newSeed < validRange.min || newSeed > validRange.max) {
                const errorMessage = `Add valid value (Range ${validRange.min} to ${validRange.max})`;
                console.log('Validation failed:', errorMessage);
                
                // Show error message using local function
                showLocalErrorMessage(errorMessage);
                
                input.value = currentSeed; // Reset to original value
                return false;
            }
            
            // Update the player's seeding in the global data
            currentPlayer.seeding = newSeed.toString();
            
            console.log('Validation passed, triggering animation');
            
            // Trigger animation with a slight delay to ensure the value is updated
            setTimeout(() => {
                sortTableBySeedClash();
            }, 100);
            
            return true;
        }

        // Function to show error message (local backup)
        function showLocalErrorMessage(message) {
            const messageBox = document.getElementById('clashMessageBox');
            if (messageBox) {
                messageBox.className = 'message error-message';
                messageBox.textContent = message;
                messageBox.style.display = 'block';
                
                // Flash the message briefly and then hide it
                setTimeout(() => {
                    messageBox.style.display = 'none';
                }, 2000); // Show for only 2 seconds
            } else {
                // Fallback to alert if message box not found
                alert(message);
            }
        }

        // Function to validate seed input against clash group range
    </script>

    <!-- Add this function to handle the toggle switch -->
    <script>
        function toggleClashMode() {
            const switchElem = document.getElementById('clashModeSwitch');
            if (switchElem && switchElem.checked) {
                setClashMode('auto');
            } else {
                setClashMode('manual');
            }
        }

        // Function to set clash mode
        function setClashMode(mode) {
            window.clashResolutionMode = mode;
            console.log('Clash mode set to:', mode);
            console.log('Current mode variable:', window.clashResolutionMode);
            
            // Update toggle switch state
            const switchElem = document.getElementById('clashModeSwitch');
            if (switchElem) {
                switchElem.checked = (mode === 'auto');
            }
            
            // Re-render the clash summary with the current mode
            if (window.currentClashes) {
                console.log('Re-rendering clash summary...');
                showClashSummary(window.currentClashes);
            }
            
            // Re-render the table if players are loaded
            const category = document.getElementById('clashCategorySelect').value;
            if (category) {
                console.log('Re-rendering table for category:', category);
                loadClashPlayers();
            } else {
                console.log('No category selected, table not re-rendered');
            }
        }

        // Shuffle function for a clash group by player ID
        function shuffleClashGroupByPlayer(playerId) {
            console.log('Shuffling clash group for player:', playerId);
            if (!window.currentPlayersWithRankings) {
                console.error('No current players data found');
                return;
            }
            
            // Find the player and their current seed
            const player = window.currentPlayersWithRankings.find(p => p.player_id === playerId);
            if (!player) {
                console.error('Player not found:', playerId);
                return;
            }
            
            const currentSeed = parseInt(player.seeding);
            const validRange = getValidSeedRangeForClash(window.currentPlayersWithRankings, currentSeed);
            
            // Find all players in the same clash group
            const clashPlayers = window.currentPlayersWithRankings.filter(p => parseInt(p.seeding) === currentSeed);
            
            // Generate possible seeds for this range
            const possibleSeeds = [];
            for (let v = validRange.min; v <= validRange.max; v++) {
                possibleSeeds.push(v);
            }
            
            // Shuffle the possible seeds
            for (let i = possibleSeeds.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [possibleSeeds[i], possibleSeeds[j]] = [possibleSeeds[j], possibleSeeds[i]];
            }
            
            // Update the table with shuffled values
            const tbody = document.getElementById('clashTableBody');
            if (!tbody) {
                console.error('Clash table body not found');
                return;
            }
            
            clashPlayers.forEach((clashPlayer, index) => {
                const rows = tbody.getElementsByTagName('tr');
                for (let row of rows) {
                    const seedCell = row.cells[2];
                    const select = seedCell.querySelector('select');
                    if (select && select.getAttribute('data-player-id') === clashPlayer.player_id) {
                        select.value = possibleSeeds[index];
                        console.log(`Updated player ${clashPlayer.name} to seed ${possibleSeeds[index]}`);
                        break;
                    }
                }
            });
            
            // Sort the table after shuffling
            sortTableBySeedClash();
        }

        // Set default mode to Manual on page load
        document.addEventListener('DOMContentLoaded', function() {
            const switchElem = document.getElementById('clashModeSwitch');
            if (switchElem) {
                switchElem.checked = false; // Manual by default
            }
            setClashMode('manual');
        });
    </script>

    <script>
        // Function to update color coding after sorting
        function updateColorCodingAfterSort() {
            const tbody = document.getElementById('clashTableBody');
            if (!tbody) return;
            
            const rows = Array.from(tbody.getElementsByTagName('tr'));
            
            // Fetch seed ranges to determine color classes
            fetch('/get_seeding_ranges')
                .then(response => response.json())
                .then(seedRangesData => {
                    if (seedRangesData.success) {
                        const seedRanges = seedRangesData.seeding_ranges;
                        
                        // Update color classes for each row based on its S.No. position
                        rows.forEach((row, index) => {
                            const snoCell = row.cells[0];
                            const serialNumber = parseInt(snoCell.textContent);
                            
                            if (serialNumber) {
                                const seedRangeClass = getSeedRangeClass(serialNumber, seedRanges);
                                row.className = seedRangeClass;
                                console.log(`Row ${index + 1}: S.No. ${serialNumber} -> Color class: ${seedRangeClass}`);
                            }
                        });
                    }
                })
                .catch(error => {
                    console.error('Error updating color coding:', error);
                });
        }

        // Function to get valid seed range for a clash group
    </script>

    <!-- Create Draws Functions -->
    <script>
        // Function to toggle draw mode between manual and automatic (removed - now using buttons)
        // The toggleDrawMode function has been removed as the toggle switch is no longer present
        // Users can now use the "Auto Assign" and "Clear Seeds" buttons for manual control

        // Function to assign seeds automatically (only to empty cells with valid unused values)
        function assignSeedsAutomatically() {
            const tbody = document.getElementById('drawPlayersTableBody');
            const rows = tbody.querySelectorAll('tr');
            
            if (rows.length === 0) {
                showDrawMessage('No players to assign seeds to', 'error');
                return;
            }

            // First, collect all currently used seeds
            const usedSeeds = new Set();
            rows.forEach((row, index) => {
                const seedSelect = row.querySelector('.seed-select');
                if (seedSelect && seedSelect.value && seedSelect.value !== '') {
                    usedSeeds.add(parseInt(seedSelect.value));
                }
            });

            console.log('Currently used seeds:', Array.from(usedSeeds));

            // Get all available seeds for each position (only for empty cells)
            const emptyPositions = [];
            rows.forEach((row, index) => {
                const seedSelect = row.querySelector('.seed-select');
                if (seedSelect) {
                    // Only process if the cell is empty
                    if (!seedSelect.value || seedSelect.value === '') {
                        const options = Array.from(seedSelect.querySelectorAll('option'));
                        const validOptions = options
                            .filter(option => option.value && option.value !== '')
                            .map(option => parseInt(option.value))
                            .filter(seed => !usedSeeds.has(seed)); // Only unused seeds
                        
                        if (validOptions.length > 0) {
                            emptyPositions.push({
                                position: index,
                                availableSeeds: validOptions,
                                row: row
                            });
                        }
                    }
                }
            });

            console.log('Empty positions with available unused seeds:', emptyPositions);

            if (emptyPositions.length === 0) {
                showDrawMessage('No empty cells with available seeds to assign', 'info');
                return;
            }

            // Assign seeds randomly to empty cells
            const assignments = [];
            const newlyUsedSeeds = new Set();

            emptyPositions.forEach((positionData) => {
                // Get seeds that are still available (not used by others and not newly assigned)
                const availableSeeds = positionData.availableSeeds.filter(seed => 
                    !newlyUsedSeeds.has(seed)
                );
                
                if (availableSeeds.length > 0) {
                    // Randomly select a seed from available options
                    const randomIndex = Math.floor(Math.random() * availableSeeds.length);
                    const selectedSeed = availableSeeds[randomIndex];
                    
                    assignments.push({
                        position: positionData.position,
                        seed: selectedSeed,
                        row: positionData.row
                    });
                    
                    newlyUsedSeeds.add(selectedSeed);
                    console.log(`Assigned seed ${selectedSeed} to position ${positionData.position + 1}`);
                }
            });

            if (assignments.length === 0) {
                showDrawMessage('No valid seeds available for assignment', 'error');
                return;
            }

            console.log(`Auto-assigned ${assignments.length} seeds to empty cells`);
            // Animate the seed assignments
            animateSeedAssignments(assignments);
        }

        // Function to animate seed assignments with scrolling
        function animateSeedAssignments(assignments) {
            const animationDuration = 500; // 500ms per assignment
            const delayBetweenAssignments = 300; // 300ms delay between assignments

            assignments.forEach((assignment, index) => {
                const delay = index * delayBetweenAssignments;
                
                setTimeout(() => {
                    const row = assignment.row;
                    const seedSelect = row.querySelector('.seed-select');
                    
                    if (seedSelect) {
                        // Highlight the row being assigned
                        row.style.backgroundColor = '#e3f2fd';
                        row.style.transition = 'background-color 0.3s ease';
                        
                        // Scroll the row into view and center it
                        row.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'center',
                            inline: 'nearest'
                        });
                        
                        // Set the seed value
                        seedSelect.value = assignment.seed;
                        
                        // Trigger change event to update dropdowns
                        const event = new Event('change');
                        seedSelect.dispatchEvent(event);
                        
                        console.log(`Animated assignment: Position ${assignment.position + 1} -> Seed ${assignment.seed}`);
                        
                        // Remove highlight after animation
                        setTimeout(() => {
                            row.style.backgroundColor = '';
                            row.style.transition = '';
                        }, animationDuration);
                    }
                }, delay);
            });

            // Show completion message
            setTimeout(() => {
                showDrawMessage(`Automatically assigned ${assignments.length} seeds successfully!`, 'success');
            }, assignments.length * delayBetweenAssignments + animationDuration);
        }

        // Function to clear all seed selections
        function clearAllSeedSelections() {
            const tbody = document.getElementById('drawPlayersTableBody');
            const seedSelects = tbody.querySelectorAll('.seed-select');
            
            seedSelects.forEach(select => {
                select.value = '';
                // Trigger change event to update dropdowns
                const event = new Event('change');
                select.dispatchEvent(event);
            });
            
            showDrawMessage('All seed selections cleared', 'success');
        }

        // Function to load draw players
        function loadDrawPlayers() {
            const category = document.getElementById('drawCategorySelect').value;
            const groupField = document.getElementById('drawGroupSelect').value;
            
            if (!category) {
                document.getElementById('drawPlayersContainer').style.display = 'none';
                return;
            }

            // Show loading state
            const tbody = document.getElementById('drawPlayersTableBody');
            tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 20px;">Loading players...</td></tr>';
            document.getElementById('drawPlayersContainer').style.display = 'block';

            // Fetch players for this category
            fetch(`/tournament/{{ tournament['Tournament Id'] }}/get_category_players/${category}?fields=full`)
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        displayDrawPlayers(data.players, groupField);
                    } else {
                        showDrawMessage('Error loading players: ' + data.message, 'error');
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    showDrawMessage('Error loading players', 'error');
                });
        }

        // Function to display draw players in the table
        function displayDrawPlayers(players, groupField) {
            const tbody = document.getElementById('drawPlayersTableBody');
            tbody.innerHTML = '';

            if (players.length === 0) {
                tbody.innerHTML = '<tr><td colspan="4" style="text-align: center; padding: 20px;">No players found for this category</td></tr>';
                return;
            }

            // Sort players by seeding
            players.sort((a, b) => {
                const seedA = parseInt(a.seeding) || 999999;
                const seedB = parseInt(b.seeding) || 999999;
                return seedA - seedB;
            });

            // Get seed ranges for color coding
            fetch('/get_seeding_ranges')
                .then(response => response.json())
                .then(seedRangesData => {
                    if (seedRangesData.success) {
                        const seedRanges = seedRangesData.seeding_ranges;
                        
                        players.forEach((player, index) => {
                            const row = document.createElement('tr');
                            
                            // Get group value based on selection
                            let groupValue = '';
                            if (groupField && groupField !== 'None') {
                                // Map the group field to the correct player data field
                                switch(groupField) {
                                    case 'State':
                                        groupValue = player.state || '';
                                        break;
                                    case 'District':
                                        groupValue = player.district || '';
                                        break;
                                    case 'School/Institution':
                                        groupValue = player.school || '';
                                        break;
                                    case 'Academy':
                                        groupValue = player.academy || '';
                                        break;
                                    default:
                                        groupValue = '';
                                }
                            }
                            
                            // Get seed range class for color coding
                            const seedRangeClass = getSeedRangeClass(index + 1, seedRanges);
                            
                            row.className = seedRangeClass;
                            row.innerHTML = `
                                <td style="text-align: center; padding: 12px;">${index + 1}</td>
                                <td style="padding: 12px;">${player.name}</td>
                                <td style="padding: 12px;">${groupValue}</td>
                                <td style="padding: 12px;">
                                    <select class="form-control seed-select" style="width: 50px !important; padding: 4px;" data-player-index="${index}" onchange="validateSeedSelection(this)">
                                        <option value=""></option>
                                        ${getValidSeedRangeForPosition(index + 1, seedRanges).map(num => 
                                            `<option value="${num}">${num}</option>`
                                        ).join('')}
                                    </select>
                                </td>
                            `;
                            tbody.appendChild(row);
                            
                            // Pre-fill existing seeding value if available
                            const seedSelect = row.querySelector('.seed-select');
                            if (player.seeding && player.seeding !== '') {
                                seedSelect.value = player.seeding;
                                console.log(`Pre-filled existing seed ${player.seeding} for player ${player.name}`);
                            } else {
                                // Auto-fill if only one valid option exists
                                const validOptions = getValidSeedRangeForPosition(index + 1, seedRanges);
                                if (validOptions.length === 1) {
                                    seedSelect.value = validOptions[0];
                                    console.log(`Auto-filled seed ${validOptions[0]} for player ${player.name} (position ${index + 1})`);
                                }
                            }
                        });
                        
                        // Update dropdowns to grey out any used seeds after all rows are added
                        setTimeout(() => {
                            updateSeedDropdowns();
                        }, 100);
                    }
                })
                .catch(error => {
                    console.error('Error fetching seed ranges:', error);
                    // Fallback without color coding
                    players.forEach((player, index) => {
                        const row = document.createElement('tr');
                        
                        let groupValue = '';
                        if (groupField && groupField !== 'None') {
                            // Map the group field to the correct player data field
                            switch(groupField) {
                                case 'State':
                                    groupValue = player.state || '';
                                    break;
                                case 'District':
                                    groupValue = player.district || '';
                                    break;
                                case 'School/Institution':
                                    groupValue = player.school || '';
                                    break;
                                case 'Academy':
                                    groupValue = player.academy || '';
                                    break;
                                default:
                                    groupValue = '';
                            }
                        }
                        
                        row.innerHTML = `
                            <td style="text-align: center; padding: 12px;">${index + 1}</td>
                            <td style="padding: 12px;">${player.name}</td>
                            <td style="padding: 12px;">${groupValue}</td>
                            <td style="padding: 12px;">
                                <select class="form-control seed-select" style="width: 50px !important; padding: 4px;" data-player-index="${index}" onchange="validateSeedSelection(this)">
                                    <option value=""></option>
                                    ${getValidSeedRangeForPosition(index + 1, seedRanges).map(num => 
                                        `<option value="${num}">${num}</option>`
                                    ).join('')}
                                </select>
                            </td>
                        `;
                        tbody.appendChild(row);
                        
                        // Pre-fill existing seeding value if available (fallback case)
                        const seedSelect = row.querySelector('.seed-select');
                        if (player.seeding && player.seeding !== '') {
                            seedSelect.value = player.seeding;
                            console.log(`Pre-filled existing seed ${player.seeding} for player ${player.name} (fallback case)`);
                        } else {
                            // Auto-fill if only one valid option exists (fallback case)
                            const validOptions = getValidSeedRangeForPosition(index + 1, seedRanges);
                            if (validOptions.length === 1) {
                                seedSelect.value = validOptions[0];
                                console.log(`Auto-filled seed ${validOptions[0]} for player ${player.name} (position ${index + 1}) - fallback case`);
                            }
                        }
                    });
                    
                    // Update dropdowns to grey out any used seeds after all rows are added (fallback case)
                    setTimeout(() => {
                        updateSeedDropdowns();
                    }, 100);
                });
        }

        // Function to show draw message
        function showDrawMessage(message, type) {
            const messageBox = document.getElementById('drawMessageBox');
            messageBox.textContent = message;
            messageBox.className = `message ${type === 'error' ? 'error' : 'success'}`;
            messageBox.style.display = 'block';
            
            setTimeout(() => {
                messageBox.style.display = 'none';
            }, 5000);
        }

        // Function to save draw changes
        function saveDrawChanges() {
            const category = document.getElementById('drawCategorySelect').value;
            if (!category) {
                showDrawMessage('Please select a category first', 'error');
                return;
            }

            // First, sort the table in ascending order
            sortTableBySeed();

            // Wait a moment for sorting to complete, then save
            setTimeout(() => {
                const tbody = document.getElementById('drawPlayersTableBody');
                const rows = tbody.querySelectorAll('tr');
                const drawData = [];

                // Collect data from the sorted table
                rows.forEach((row, index) => {
                    const cells = row.querySelectorAll('td');
                    if (cells.length >= 4) {
                        const name = cells[1].textContent.trim();
                        const seedSelect = cells[3].querySelector('select');
                        const selectedSeed = seedSelect ? seedSelect.value : '';
                        
                        if (name && selectedSeed) {
                            drawData.push({
                                name: name,
                                seeding: selectedSeed
                            });
                        }
                    }
                });

                if (drawData.length === 0) {
                    showDrawMessage('No valid draw data to save', 'error');
                    return;
                }

                // Show loading state
                const saveButton = document.getElementById('saveDrawButton');
                const originalText = saveButton.innerHTML;
                saveButton.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Saving...';
                saveButton.disabled = true;

                // Send data to server
                fetch('/save_tournament_draw', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        tournamentId: '{{ tournament["Tournament Id"] }}',
                        category: category,
                        drawData: drawData
                    })
                })
                .then(response => response.json())
                .then(data => {
                    if (data.success) {
                        showDrawMessage('Draw saved successfully!', 'success');
                    } else {
                        showDrawMessage('Error saving draw: ' + data.message, 'error');
                    }
                })
                .catch(error => {
                    console.error('Error:', error);
                    showDrawMessage('Error saving draw', 'error');
                })
                .finally(() => {
                    // Restore button state
                    saveButton.innerHTML = originalText;
                    saveButton.disabled = false;
                });
            }, 100); // Small delay to ensure sorting completes
        }

        // Add event listeners for Create Draws
        document.addEventListener('DOMContentLoaded', function() {
            const drawCategorySelect = document.getElementById('drawCategorySelect');
            const drawGroupSelect = document.getElementById('drawGroupSelect');
            
            if (drawCategorySelect) {
                drawCategorySelect.addEventListener('change', loadDrawPlayers);
            }
            
            if (drawGroupSelect) {
                drawGroupSelect.addEventListener('change', loadDrawPlayers);
            }
        });

        // Function to sort table by seed with animation (ascending only)
        function sortTableBySeed() {
            const tbody = document.getElementById('drawPlayersTableBody');
            if (!tbody) {
                console.error('Table body not found');
                return;
            }

            const rows = Array.from(tbody.querySelectorAll('tr'));
            if (rows.length === 0) {
                console.log('No rows to sort');
                return;
            }

            // Always sort in ascending order
            const isAscending = true;

            // Update sort icon to show ascending
            const seedHeader = document.querySelector('th[onclick="sortTableBySeed()"]');
            const sortIcon = seedHeader.querySelector('i');
            sortIcon.className = 'fas fa-sort-up';

            // Create array of row data with seed values
            const rowData = rows.map((row, index) => {
                const cells = row.querySelectorAll('td');
                const seedSelect = cells[3].querySelector('select');
                const seedValue = seedSelect ? seedSelect.value : '';
                // Treat blank/empty values as highest seed (999999)
                const numericSeed = seedValue === '' ? 999999 : parseInt(seedValue) || 999999;
                
                return {
                    row: row,
                    seedValue: numericSeed,
                    originalSeed: seedValue,
                    originalIndex: index,
                    sno: cells[0].textContent.trim() // Preserve S.No.
                };
            });

            // Sort by seed value in ascending order - blank rows treated as highest seed
            rowData.sort((a, b) => a.seedValue - b.seedValue);

            // Sort instantly without animation
            sortTableInstantly(tbody, rowData, isAscending);
        }

        // Function to sort table instantly without animation
        function sortTableInstantly(tbody, sortedRowData, isAscending) {
            console.log('Sorting table instantly in ascending order');
            
            // Reorder DOM and update S.No.
            sortedRowData.forEach((rowData, finalIndex) => {
                const finalRow = rowData.row;
                const cells = finalRow.querySelectorAll('td');
                cells[0].textContent = rowData.sno;
                tbody.appendChild(finalRow);
            });
            
            // Update dropdowns
            setTimeout(() => {
                updateSeedDropdowns();
            }, 100);
            
            console.log(`Table sorted by seed in ascending order`);
        }


    </script>

    <script>
        // Global category synchronization function
        function synchronizeCategorySelection() {
            const selectedCategory = this.value;
            const seedingCategorySelect = document.getElementById('seedingCategorySelect');
            const clashCategorySelect = document.getElementById('clashCategorySelect');
            const drawCategorySelect = document.getElementById('drawCategorySelect');
            
            // Sync to Update Seeding
            if (seedingCategorySelect && seedingCategorySelect !== this) {
                seedingCategorySelect.value = selectedCategory;
                if (seedingCategorySelect.value) {
                    const event = new Event('change');
                    seedingCategorySelect.dispatchEvent(event);
                }
            }
            
            // Sync to Resolve Seeding Clash
            if (clashCategorySelect && clashCategorySelect !== this) {
                clashCategorySelect.value = selectedCategory;
                if (clashCategorySelect.value) {
                    const event = new Event('change');
                    clashCategorySelect.dispatchEvent(event);
                }
            }
            
            // Sync to Create Draw
            if (drawCategorySelect && drawCategorySelect !== this) {
                drawCategorySelect.value = selectedCategory;
                if (drawCategorySelect.value) {
                    const event = new Event('change');
                    drawCategorySelect.dispatchEvent(event);
                }
            }
        }

        // Initialize Step 1
        const seedingCategorySelect = document.getElementById('seedingCategorySelect');
        if (seedingCategorySelect) {
            seedingCategorySelect.addEventListener('change', loadPlayers);
        }

        // Initialize seeding form
        const seedingForm = document.getElementById('seedingForm');
        if (seedingForm) {
            seedingForm.addEventListener('submit', saveSeeding);
        }

        // Initialize Step 2 (Resolve Seeding Clash)
        const clashCategorySelect = document.getElementById('clashCategorySelect');
        if (clashCategorySelect) {
            clashCategorySelect.addEventListener('change', loadClashPlayers);
        }

        // Initialize Step 3
        const drawCategorySelect = document.getElementById('drawCategorySelect');
        if (drawCategorySelect) {
            drawCategorySelect.addEventListener('change', handleDrawCategoryChange);
        }

        const createDrawBtn = document.getElementById('create-draw-btn');
        if (createDrawBtn) {
            createDrawBtn.addEventListener('click', startShuffling);
        }

        const stopShuffleBtn = document.getElementById('stop-shuffle-btn');
        if (stopShuffleBtn) {
            stopShuffleBtn.addEventListener('click', stopShuffling);
        }

        const saveDrawBtn = document.getElementById('save-draw-btn');
        if (saveDrawBtn) {
            saveDrawBtn.addEventListener('click', saveDraw);
        }

        // Show the first step by default
        showStepContent(1);
    </script>

    <script>
        // Function to validate seed selection and prevent duplicates
        function validateSeedSelection(selectElement) {
            const selectedValue = selectElement.value;
            const currentPlayerIndex = parseInt(selectElement.getAttribute('data-player-index'));
            
            if (!selectedValue) {
                // If clearing selection, update all dropdowns to remove grey-out
                updateSeedDropdowns();
                return;
            }
            
            // Get all seed selects in the table
            const allSeedSelects = document.querySelectorAll('.seed-select');
            let duplicateFound = false;
            let duplicatePlayerName = '';
            
            // Check for duplicates
            allSeedSelects.forEach((select, index) => {
                if (index !== currentPlayerIndex && select.value === selectedValue) {
                    duplicateFound = true;
                    const row = select.closest('tr');
                    const nameCell = row.cells[1];
                    duplicatePlayerName = nameCell.textContent.trim();
                }
            });
            
            if (duplicateFound) {
                // Reset to empty and show error message
                selectElement.value = '';
                showDrawMessage(`Seed ${selectedValue} is already assigned to ${duplicatePlayerName}. Please select a different seed.`, 'error');
                // Update dropdowns after clearing
                updateSeedDropdowns();
            } else {
                // Valid selection, update all dropdowns to grey out used seeds
                updateSeedDropdowns();
            }
        }

        // Function to update all seed dropdowns to grey out used seeds
        function updateSeedDropdowns() {
            try {
                const allSeedSelects = document.querySelectorAll('.seed-select');
                if (allSeedSelects.length === 0) {
                    console.log('No seed dropdowns found, skipping update');
                    return;
                }
                
                const usedSeeds = new Set();
                
                // Collect all currently used seeds
                allSeedSelects.forEach(select => {
                    if (select.value && select.value !== '') {
                        usedSeeds.add(parseInt(select.value));
                    }
                });
                
                // Update each dropdown to grey out used seeds
                allSeedSelects.forEach(select => {
                    const currentValue = select.value;
                    const options = select.querySelectorAll('option');
                    
                    options.forEach(option => {
                        if (option.value && option.value !== '') {
                            const seedValue = parseInt(option.value);
                            if (usedSeeds.has(seedValue) && seedValue !== parseInt(currentValue)) {
                                // Grey out this option (already used by another player)
                                option.disabled = true;
                                option.style.color = '#999';
                                option.style.backgroundColor = '#f5f5f5';
                            } else {
                                // Enable this option (not used or used by current player)
                                option.disabled = false;
                                option.style.color = '';
                                option.style.backgroundColor = '';
                            }
                        }
                    });
                });
                
                console.log('Updated seed dropdowns, used seeds:', Array.from(usedSeeds));
            } catch (error) {
                console.error('Error updating seed dropdowns:', error);
            }
        }
    </script>

    <script>
        // Function to get valid seed range for a player position based on seeding ranges
        function getValidSeedRangeForPosition(position, seedRanges) {
            // Find which seed range this position belongs to
            for (const range of seedRanges) {
                if (position >= range.min && position <= range.max) {
                    // Generate array of valid seed values for this range
                    const validSeeds = [];
                    for (let i = range.min; i <= range.max; i++) {
                        validSeeds.push(i);
                    }
                    return validSeeds;
                }
            }
            
            // If no range found, return the full range
            const maxSeed = Math.max(...seedRanges.map(r => r.max));
            const validSeeds = [];
            for (let i = 1; i <= maxSeed; i++) {
                validSeeds.push(i);
            }
            return validSeeds;
        }

        // Function to load draw players
    </script>
</body>
</html>
